# Q) 39. ConstraintLayout 이란 무엇인가요?


## 번외) Compose의 Layout은 성능이 왜 괜찮을까?

Android XML 에서는 Linear Layout 성능이 안좋다는 이유로 Constraint Layout 을 권장하고 있습니다.

하지만 compose 를 경험해보시면 화면을 그릴 때에는 Linear Layout 을 그리는 방식처럼 만들고 있는 것을 알 수 있어요.
예를 들어서 Column 안에.. Row 안에 ... Column ...

이러한 방식이 compose 에서는 성능이 괜찮을까요??

먼저 그러면, **Linear Layout** 과 **Constraint Layout** 방식에 대해서 알아보겠습니다.


### Linear Layout
`LinearLayout`은 보기를 가로(`horizontal`) 또는 세로(`vertical`)로 한 방향에 맞춰 배치하는 단순한 레이아웃입니다.
뷰를 순서대로 나열하는 데 적합하며, 구조가 간단할 때는 빠르고 효율적입니다.

**내부 동작 원리**

* **스택 기반 배치:** 자식 뷰를 한 방향으로 순차 정렬
* **두 단계 측정:**

    1. **Measure:** 각 자식의 크기를 측정
    2. **Layout:** 측정 결과를 기반으로 위치를 결정
* 하지만 **중첩된 LinearLayout**은 `measure → layout → draw` 과정이 반복되기 때문에 성능 저하가 발생합니다.
  (특히 `layout_weight`를 사용하면 여러 번의 측정 패스가 필요합니다.)

### Constraint Layout
`ConstraintLayout`은 **제약 조건(Constraint)** 을 이용해 뷰 간의 관계를 정의하고,
**하나의 평면(Flat hierarchy)** 안에서 복잡한 배치를 가능하게 합니다.

**내부 동작 원리**

* **Constraint Graph 기반:** 각 뷰가 다른 뷰 또는 부모 레이아웃과의 관계를 그래프로 정의
* **ConstraintSolver 엔진:** 전체 뷰의 크기와 위치를 **한 번의 패스**로 계산
* **중첩 불필요:** 여러 개의 LinearLayout이나 RelativeLayout을 중첩하지 않아도 복잡한 UI 구성 가능

👉 결과적으로 **측정·배치 과정이 단일화되어 성능이 개선**되고,
UI 구조도 단순해져 유지보수성이 높아집니다.

### LinearLayout 과 ConstraintLayout 성능 비교
| 항목           | LinearLayout           | ConstraintLayout     |
| ------------ | ---------------------- | -------------------- |
| **구조**       | 중첩이 많아질 수 있음           | 대부분의 배치를 하나로 표현 가능   |
| **측정 패스**    | 중첩 시 measure/layout 반복 | 단일 패스로 계산 가능         |
| **OverDraw** | 겹치는 경우 GPU 부담 ↑        | 제약 조건 기반으로 최소화 가능    |
| **가독성**      | 단순 UI에 유리              | 복잡한 UI도 평면 구조로 관리    |
| **성능 최적화**   | 뷰 개수 증가 시 비용 급증        | 계층이 얕아 측정·레이아웃 비용 절감 |

### View Hierarchy 성능 원리 (공식 문서 요약)

Android의 **렌더링 파이프라인**은 다음과 같은 단계를 거칩니다:

> Measure → Layout → Draw

각 단계마다 View가 많거나 중첩이 깊을수록 비용이 커집니다.
특히 다음 경우 성능 저하가 발생합니다:

* **View 계층이 깊은 경우**
* **`RelativeLayout`이나 weighted `LinearLayout`처럼 두 번의 측정(double taxation)** 이 필요한 경우
* **RecyclerView 안에서 복잡한 item layout을 재활용할 때**

**해결책:**

* **ConstraintLayout** 사용 → 불필요한 중첩 제거
* **`<merge>` 태그**로 중복된 상위 레이아웃 제거
* **Lint / Layout Inspector / Perfetto** 를 통해 뷰 계층 구조 확인 및 최적화

> “The flatter your hierarchy, the less time it takes for the layout stage to complete.”
> *(공식 문서)*
> 
### Compose Layout
XML 기반 뷰 시스템에서는 중첩된 LinearLayout이 성능 저하를 일으키기 때문에
**ConstraintLayout으로 평탄화(flatten)** 하는 것이 중요했습니다.
하지만 **Jetpack Compose**는 **동작 원리 자체가 다릅니다.**

Compose의 프레임 처리 3단계
1. **Composition** – 어떤 UI를 그릴지 결정 (Composable 함수 실행 → UI 트리 구성)
2. **Layout** – 각 요소의 크기와 위치를 계산 (MeasurePolicy 기반)
3. **Draw** – 실제 화면에 렌더링

Compose는 이 세 단계를 모두 수행하지 않습니다.
→ **상태(State)** 가 변한 요소만 “부분적으로 다시 계산(recomposition)” 합니다.

예를 들어 크기나 배치가 바뀌지 않고 **색상만 변경되는 경우**,

* `Composition` 생략
* `Layout` 생략
* `Draw`만 다시 수행

즉, View 시스템처럼 전체 트리를 다시 측정하지 않고 **변경된 부분만 업데이트**합니다.

### 💡 왜 Column, Row처럼 중첩해도 괜찮은가?

* Compose의 `Column`, `Row`, `Box` 등은 **가벼운 함수(Composable)** 이며,
  실제 View 객체를 생성하지 않습니다.
* XML의 LinearLayout과 달리 **Slot Table**이라는 메모리 구조에 기록되어,
  중첩이 많아도 **실제 Measure/Layout 트리의 깊이가 얕습니다.**
* 필요 시 Intrinsic Measurement(내장 측정)으로 두 번 측정할 수도 있지만,
  기본적으로는 한 번의 측정으로 대부분 처리합니다.

### 실전 질문
Q) ConstraintLayout은 중첩된 LinearLayout 및 RelativeLayout과 비교하여 성능을 어떻게 향상시키나요?
ConstraintLayout 사용이 더 효율적인 시나리오를 말씀해주세요.<br/>
기존 LinearLayout이나 RelativeLayout은 중첩이 많을수록
각 단계마다 measure → layout → draw 과정이 반복되어 성능이 기하급수적으로 저하됩니다.

반면 ConstraintLayout은 ConstraintSolver(제약 해석 엔진) 을 사용해
모든 뷰의 위치를 한 번에 계산하므로 뷰 트리가 얕고, 측정 과정이 단일 패스로 끝납니다.

즉, UI 복잡도는 높지만 뷰 계층은 단순하게 유지할 수 있어 렌더링 효율이 높습니다.

Q) ConstraintLayout에서 match_constraint (0dp) 동작이 어떻게 작동하는지 설명해주세요.
wrap_content 및 match_parent와 어떻게 다르며, 어떤 상황에서 사용해야 하나요?<br/>
match_constraint(0dp)은 주어진 제약 범위 내에서 가능한 최대 크기를 차지합니다.