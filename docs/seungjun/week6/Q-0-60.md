# Q) 60. Json 형식을 객체로 어떻게 직렬화(serialize)하나요?

### 직렬화(Serialization)와 역직렬화(Deserialization)
직렬화(Serialization): 객체나 데이터 구조를 나중에 쉽게 저장, 전송 또는 재구성할 수 있는 형식으로 변환하는 프로세스
안드로이드와 백엔드 통신 통신에서 JSON 문자열과 같이 유사한 구조화된 형식으로 변환하는 것을 의미<br/>
역직렬화(Deserialization): 직렬화된 데이터를 가져와 애플리케이션에서 작업할 수 있는
메모리 내 객체로 다시 재구성하는 역 프로세스

### 직렬화 라이브러리

#### 수동 직렬화 및 역직렬화
단순히 문자열 조작 및 파싱 기술을 통해 객체를 변환하는 방식을 의미합니다.

#### kotlinx.serialization
JetBrains 에서 개발한 라이브러리로 kotlin 과 통합되어 활용되도록 설계
어노테이션을 사용해 직렬화 동작을 정의하고 JSON 뿐 아니라 ProtoBuf 와 같은 다른 형식과도 원활하게 작동


#### Moshi
Square 에서 개발한 Moshi 는 타입 안전성과 Kotlin 지원을 강조하는 최신 JSON 라이브러리
Kotlin 의 null 가능성 및 기본 매개변수를 기본적으로 지원

직렬화 처리 방법이 두가지를 가지고 있다
- 리플렉션 기반 동작 방식<br/>
  리플렉션 기반은 Java 리플렉션을 사용해 런타임에 동적으로 JSON 어댑터를 생성, 추가 설정 없이 간단하다
  but, 런타임 오버헤드 발생
- 컴파일 타임에 코드를 생성하는 방식<br/>
  어노테이션 프로세스 기법을 통해 컴파일 타임에 JSON 어댑터를 생성해, 더 빠른 런타임 성능과 컴파일 타임 오류 검사를 제공

#### Gson
Google 에서 개발한 JSON 라이브러리
Java 객체를 JSON 으로 직렬화하고 JSON 을 다시 Java 객체로 역직렬하는 라이브러리

Gson 보다 Kotlinx.serialization 좋은 명백한 이유가 있다.

1. kotlin 용 기반 지원 : Gson 은 Java 용으로 설계되어 Kotlin 기능을 자연스럽게 처리하지 못함
2. 성능 및 효율성 : 런타임에 리플렉션에 크게 의존하는 Gson 보다 빠르고 메모리 효율적
    리플렉션 방식의 경우 런타임에 클래스 구조를 파악해 각 필드 타입을 런타입으로 확인하기 때문에 변환 속도가 매우 느리다.
3. 멀티 플랫폼 호환성: Gson 은 JVM 위에 동작하도록 설계되어 있기 때문에 크로스 플랫폼 앱에 적합하지 않다.
4. 컴파일 타임 안전성: 마찬가지로 Gson 은 런타임 오류로 크래시 발생할 가능성이 높다.


### 실전 질문
Q) API의 JSON 응답이 주어졌을 때, 이를 Kotlin 데이터 클래스로
어떻게 역직렬화하시겠습니까? Kotlin을 사용하는 프로젝트에서 어떤 라이브러리를 선택할 것이고, 그 이유는 무엇인가요?

kotlinx.serialization 을 사용할 것 입니다. 기본적으로 kotlin 과 통합되어 설계되어 궁합이 잘 맞고
향후, 멀티플랫폼 확장을 고려했을때 이를 사용하는 것이 적합하고, 컴파일 타임 안전성, 경량 런타임 및 완전한 네티이브 kotlin 지원을
제공하기 때문입니다.


Q) Kotlin 데이터 클래스에 정의되지 않은 누락되거나 추가적인 필드가
있는 JSON 문자열을 역직렬화해야 하는 경우 어떻게 처리하실 건가요?
kotlinx.serialization 기준으로 설명하자면,
필요없는 필드는 무시하는 옵션인 `ignoreUnknownKeys = true` 옵션을 설정하고
누락될 수 있는경우에는 기본값을 주거나, nullable 로 정의하거나, 정말 필수적인 데이터라면 예외를 
발생시켜 상위에서 처리하는 방식으로 설계하겠습니다.