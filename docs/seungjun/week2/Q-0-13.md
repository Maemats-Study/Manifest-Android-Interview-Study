# Q) 13. 안드로이드는에서 메모리를 어떻게 효율적으로 관리하며, 메모리 누수(memory leaks)를 어떻게 방지하는지 설명해주세요.

안드로이드에서 메모리 관리시에 가비지 컬렉션을 이용해 메모리를 관리합니다.
Dalvik 또는 ART 런타임은 메모리 사용량을 모니터링하고, 더이상 참조되지 않는 객체를 정리하며, 과도한 메모리 소비를 방지합니다.

안드로이드에서는 시스템 메모리가 부족한 경우 포그라운드 애플리케이션의 원활한 작동을 우선시하여,
low-memory killer(LMK) 를 사용해 백그라운 프로세스를 종료합니다. 따라서 시스템 성능에 미치는 영향을 최소화하기 위해
앱이 가지는 메모리 리소스를 효율적으로 사용하도록 해야합니다.

안드로이드에서 메모리 누수 원인
메모리 누수는 애플리케이션이 더 이상 필요하지 않는 객체에 대한 참조를 유지하여 가비지 컬렉터가 메모리를 
회수하지 못하게 할 때 발생합니다.
일반적으로 부적절한 생명주기 관리, 정적 참조 또는 Context 참조 등이 원인입니다.

### 메모리 누수를 피하기 위한 모범 사례
1. 생명주기를 인지하는 컴포넌트 사용:<br/>
ViewModel, `collectAsStateWithLifecycle` Flow 또는 `LiveData` 와 같이
생명주기를 인지하는 컴포넌트를 활용해 관련 생명주기가 끝날 때 리소스가 적절하게 해제됩니다.<br/><br/>
    <details>
    <summary>collectAsStateWithLifecycle?</summary>
   
    `collectAsStateWithLifecycle` 은 `flow` 에서 값을 수집하고 최신 값을 Compose state 로
    나타내는 라이프사이클 인식 방식의 `composable` 함수<br/><br/>
    기본적으로 내부 코드는 `repeatOnLifecycle` API 를 사용하여 구현하고, `Lifecycle.State.STARTED` 를
    사용해 flow 에서 값을 수집하거나 중지합니다.<br/>
   
    `collectAsStateWithLifecycle` 이 Android 에서 Composable 함수로부터 flow를
    수집하는 가장 안전한 방법이라면 왜 `collectAsState` API 가  필요할까요?<br/>
 
    `collectAsState` 도 `collectAsStateWithLifecycle` 내부 구현을 직접 할 수 있지만,
    이는 보일러 플레이트 코드를 발생시킵니다.
    기본적으로 `collectAsState` API 는 `Composition` 의 라이프 사이클을 따릅니다.
    이는 flow 를 수집하는데 사용할 수 있는 플랫폼에 구애 받지 않는 API 입니다.
    
    따라서 Android 앱 개발시에는 안전한 `collectAsStateWithLifecycle` 을 쓰는 것이 좋고,
    다른 플랫폼 개발을 위해서는 `collectAsState` 를 사용합니다.
    </details>
   <br/>
2. Context 에 대한 오랜 참조 피하기:<br/>
정적 필드나 싱글톤과 같이 오래 지속되는 객체에서 `Activity` 또는 `Context` 에 대한 참조를
유지하지 않아야합니다. `Context` 에 대한 장기적인 참조가 필요하다면 `Activity` 나 `Fragment` 의 생명주기와는
독립적인 `ApplicationContext` 를 사용합니다.
<br/><br/>
3. 리스너 및 콜백 등록 올바르게 해제하기:<br/>
적잘한 생명주기 메서드에서 Listener, Observer, Call back 함수 등록을 올바르게 해제해야합니다.
ex) `onPause()`, `onStop()` 등에서 `BroadcastReceiver` 등록을 해제해야 앱이 백그라운드 있을 때 참조 하지 않습니다.
<br/><br/>
4. 중요하지 않은 객체 WeakReference 사용하기:<br/>
Reference 는 적절한 상태에 따라 GC 가 제거할 데이터에
우선 순위를 부여하여 효율적으로 메모리를 관리하기 위해 분류됩니다.<br/><br/>
    Reference 종류
    - Strong : 기본 적으로 객체 생성시 생기는 참조형태, GC 가 일어나지 않습니다.
    - Soft : 메모리에 여유가 없다면 GC 에 수거, 충분한경우 GC 에 의해 수거되지 않습니다.
    - Weak : 명시적으로 GC 회수 알고리즘에 따라 회수 됩니다. NPE 발생 가능성
    - Phantom : finalize() 메소드의 단점(객체 재생성 가능성) 을 없애고, 객체 제거시 호출하는 메소드를 처리하기 위함에 사용합니다.
    <br/><br/>

   장기적으로 참조가 보장되어야하는 객체가 아니라면, 예를들어 캐쉬와 같이 
   `WeakReference` 를 사용하는 것이 좋습니다. `WeakReference` 로 참조하는 객체는 메모리가 필요할 때 가비지 컬렉터가 해당 객체를 
   언제든지 회수할 수 있습니다.
<br/><br/>
5. 누수 감지 툴 사용:<br/>
메모리 누수 탐지 툴인 LeakCanary 와 같은 툴을 활용할 수 있습니다.<br/>
Android Studio 의 Memory Profiler 를 사용해 버범거림, 멈춤 현상,
메모리 누수를 발생시키는 변수를 확인할 수 있습니다.
<br/><br/>
6. View 에 대한 정적 참조 피하기:<br/>
View 는 Activity 컨텍스트에 대한 참조를 유지하여 메모리 누수를 유발할 수 있으므로
정적 필드에 저장해서는 안됩니다.
<br/><br/>
7. 리소스 닫기:<br/>
파일 스트림, Cursor 또는 데이터베이스 연결과 같은 리소스는 더 이상 필요하지 않을 때
항상 명시적으로 해제합니다.
<br/><br/>
8. Fragment 처리:<br/>
Fragment 에서 바인딩 객체를 과도하게 사용하거나 부적절한 참조를 유지하지 않고, onDestroyView() 또는
onDetach() 에서 Fragment 참조를 정리합니다.

### 실전 질문
Q) 애플리케이션에서 메모리 누수의 일반적인 원인은 무엇이며, 이를
사전에 방지하기 위한 방법에는 어떤 것들이 있나요?<br/>
가비지 컬렉터가 강한참조로 인해 메모리를 회수하지 못하여, OutOfMemoryError 가 발생합니다.
기본적으로는 생명 주기에 따라 불필요한 참조로 인한 메모리 할당이 원인이기 때문에,
생명 주기에 맞춰 명시적으로 참조를 해제하는 것이 중요합니다.

Q) 안드로이드의 가비지 컬렉션 메커니즘은 어떻게 작동하며, 개발자는
앱에서 메모리 누수를 감지하고 수정하기 위해 어떤 방법을 사용할 수
있나요?

`Reachability`(도달 가능한 상태) 를 파악하여, 루트 집합에서 시작해 참조되는 객체들을
추적하여 존재한다면 `Reachable`, 유효한 참조가 없다면 `Unreachable` 로 구분되어 수거됩니다.
개발자는 가비지 컬렉션의 동작 방식을 이해하고 이를 고려하여 코드를 작성할 뿐, 직접적으로 호출하거나 정의하지 않습니다.
