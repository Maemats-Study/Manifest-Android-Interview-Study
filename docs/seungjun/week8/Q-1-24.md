# Q) 24. 컴포저블 함수에서 Kotlin의 Flow를 메모리 누수없이 안전하게 관찰하는 방법은 무엇인가요?

### collectAsState

Flow 를 수집하고 이를 State 객체로 변환해 주는 편리한 API

컴포저블 함수 내에서 직접 상태와 동일한 형태로 사용 가능, **flow 가 새 값을 방출**할 때마다 **상태 값에 반영**되어 `recomposition` 을 트리거 할수 있다.

이는 안드로이드 생명주기를 인지하는 것은 아니기에 CMP 에서 사용할때 사용한다.

기본적인 안드로이드 프로젝트라면 `collectAsState` 보다는 `collectAsStateWithLifecycle` 을 사용하자.

### collectAsStateWithLifecycle

Flow 수집이 안드로이드 생명주기를 따르도록 보장하는 안드로이드 전용 API

컴포저블 함수가 포그라운드에 있지 않으면 Flow 수집을 자동으로 일시 중지하여 불필요한 백그라운드 작업을 방지

`androidx.lifecycle:lifecycle‑runtime‑compose` 패키지에서 제공

```kotlin
@Composable
public fun <T> Flow<T>.collectAsStateWithLifecycle(
    initialValue: T,
    lifecycle: Lifecycle,
    minActiveState: Lifecycle.State = Lifecycle.State.STARTED,
    context: CoroutineContext = EmptyCoroutineContext
): State<T> {
    return produceState(initialValue, this, lifecycle, minActiveState, context) {
        lifecycle.repeatOnLifecycle(minActiveState) {
            if (context == EmptyCoroutineContext) {
                this@collectAsStateWithLifecycle.collect { this@produceState.value = it }
            } else
                withContext(context) {
                    this@collectAsStateWithLifecycle.collect { this@produceState.value = it }
                }
        }
    }
}
```

내부적으로 repeatOnLifecycle 을 통해 STARTED 상태일때만 동작하도록 구현되어 있음

### 실전 질문

Q) collectAsState는 안드로이드 생명주기를 인지하지 못하기 때문에
UI가 보이지 않을 때도 계속 Flow를 수집하여 잠재적인 메모리 누수
를 유발할 수 있습니다. 이 문제를 어떻게 해결할 수 있나요? 만약collectAsStateWithLifecycle를 사용하지 않고 직접 해결해야 한다면 어
떻게 구현하실 건가요?