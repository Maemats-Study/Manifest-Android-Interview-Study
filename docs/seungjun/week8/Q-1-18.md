# Q) 18. snapshotFlow를 사용해 본 경험이 있을까요? 사용 시 주의 사항은 무엇인가요?

`snapshotFlow` 는 Compose 의 상태를 Flow 로 변환하는 함수

Snapshot 시스템 내에서 변경 사항을 관찰하고, 관찰된 상태가 변경될 때마다 Flow 는 업데이트된 값을 내보냅니다.

Compose 상태 변경시 이를 수신해 Flow 로 방출하는 상태 업데이트 관리

**주요 특징**

- 상태 관찰: Snapshot 시스템을 사용해 Compose 상태 변환 관찰
- 스레드 안전성: Compose 스냅샷스코프 내에서 상태 읽기, 쓰기가 발생해 race condition 방지
- 유후 건너뛰기(Idel Skipping): 상태 값이 변경될 때만 Flow 값으로의 방출이 발생 recompostion 이 발생하지 않는 중에는 업데이트를 건너 뜀
- 취소 인지: Flow 수집하는 코루틴이 취소 될때, 구독도 자동으로 취소 되어 컴포지션 생명주기를 인지하는 형태로 동작

사용 예

- 코루틴과 인터페이스: 변환, 플로우 결합 또는 필터링과 같은 추가적인 Flow 연산 작업이 필요한 경우 Compose 상태를 코루틴 플로우로 변경해 사용
- 비 UI 사이드 이펙트: UI 에 직접적으로 관련이 없는 사이드 이펙트 작업을 수행하기에 적합

**사용법**

상태가 변경될 때마다 작업을 수행하는 코드

```kotlin
@Composable
fun SnapshotFlowExample(viewModel: MyViewModel) {
    val count by viewModel.count.collectAsState()
    
    LaunchedEffect(Unit) { // 컴포지션 진입시 한번 수행
        snapshotFlow { count } // count 상태 변경 감지
            .collect { value ->
                // 최신 값으로 사이드 이펙트 작업 수행
                // 예: 로그 기록, 분석 이벤트 전송 등 무겁지 않은 동작
                println("Count value changed to: $value")
            }
     }
     
     Text(text = "Count: $count")
}
```

스크롤시 필요할때마다 **Paginiation 데이터 불러오기**

`shouldLoadMore` 조건이 `true` 될때만 pagination 요청 전송

```kotlin
@Composable
fun LazyListState.OnBottomReached(
    threshold: Int = 0,
    isLoading: Boolean,
    onLoadMore: () -> Unit,
) {
    require(threshold >= 0) { "threshold cannot be negative, but was $threshold" }
    
    val loading by rememberUpdatedState(isLoading)
    val loadMore by rememberUpdatedState(onLoadMore)
    
    // 추가 목록을 불러 와야하는지 판단
    val shouldLoadMore by remember {
        derivedStateOf {
            val total = layoutInfo.totalItemsCount
            if (total == 0) return@derivedStateOf false

            val lastVisible = layoutInfo.visibleItemsInfo.lastOrNull()?.index ?: -1
            val reached = lastVisible + threshold >= total - 1

            reached && !loading
        }
    }
		
		// listState 가 변경 될때마다 LuanchedEffect 재실행
    LaunchedEffect (this) {
        snapshotFlow { shouldLoadMore } // 첫 번째 보이는 아이템 인덱스 관찰
            .distinctUntilChanged() // 값이 실제로 변경될 때만 방출
            .filter { it } // shouldLoadMore 가 true 일 떄만 방출
            .collect {
                // pagination 구현을 위해 추가 항목을 불러오는 이벤트 전송
                onLoadMore()
            }
    }
}
```

**유의 사항**

- **스레드 안전성 및 수집(Thread Safety and Collection)**

  수집된 플로우가 일반적으로 LauncehdEffect 를 사용하는 코루틴 스코프 내에서 처리되도록 하여 컴포지션 외부에서 수집하는 것을 방지하고 메모리 누수를 방지합니다.

- **방출 빈도(Emission Frequency)**

  람다 내에서 읽은 스냅샷 상태가 변경될 때마다 값을 방출해, 자주 발생 할 수 있습니다.

  `distinctUnitlChanged()` 또는 `debounce()` 와 같은 연산자를 사용해 불필요한 방출을 줄이고 성능을 최적화 합니다.

- **스냅샷 격리(Snapshot Isolation)**

  격리된 스냅샷 기반으로 방출되어, 스냅샷 생명주기 내 예상되는 동작을 보장하기 위해 다른 Flow 또는 suspend 함수와 결합할 때 주의해야합니다.


### 실전 질문

Q) snapshotFlow를 사용하는 것이 선호되는 시나리오는 무엇이며, 이는 Compose의 스냅샷 시스템과 어떠한 연관이 있나요? 또한, Flow에서 값을 방출하는 동작을 어떻게 최적화하시겠습니까?