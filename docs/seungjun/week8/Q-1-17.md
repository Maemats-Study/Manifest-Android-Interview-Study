# Q) 17. produceState의 목적은 무엇이며 어떻게 작동하나요?

`produceState` 함수는 새로 시작된 코루틴에 의해 값이 생성되는 State 객체를 만드는데 도움이 됩니다.

주로 비동기 작업에 의존하는 상태를 관리하고자 할때, non-Compose 상태를 Compose 상태로 변환해야할 때 사용합니다.

컴포저블이 관찰할 수 있는 State 객체를 생성하고, 상태 값을 업데이트 하기위해 생산자(producer) 코루틴을 실행하며, 컴포저블이 컴포지션을 떠날 때 코루틴 스코프를 자동으로 취소합니다.

```kotlin
@Composable
public fun <T> produceState(
    initialValue: T,
    vararg keys: Any?,
    producer: suspend ProduceStateScope<T>.() -> Unit,
): State<T> {
    val result = remember { mutableStateOf(initialValue) }
    @Suppress("CHANGING_ARGUMENTS_EXECUTION_ORDER_FOR_NAMED_VARARGS")
    LaunchedEffect(keys = keys) { ProduceStateScopeImpl(result, coroutineContext).producer() }
    return result
}

// ProduceStateScope 인터페이스를 구현
private class ProduceStateScopeImpl<T>(
    state: MutableState<T>,
    override val coroutineContext: CoroutineContext,
) : ProduceStateScope<T>, MutableState<T> by state {
    
    // 생산자 코루틴 취소시 정리 작업을 수행하는 suspend 함수
    override suspend fun awaitDispose(onDispose: () -> Unit): Nothing {
        try {
            // 코루틴이 취소될 때까지 일시 중단
            suspendCancellableCoroutine<Nothing> {}
        } finally {
            // 취소시 onDispose 람다 실행
            onDispose()
        }
    }
}
```

- **initialValue**: 생산자가 코루틴을 실행하고 상태 업데이트를 시작하기 전 초기값
- **keys**: 생산자의 코루틴은 키값에에 따라 키값이 변경되면 기존 생산자 코루틴은 취소되고 다시 시작됩니다.
- **producer**: 코루틴 동작을 수행하고 상태를 업데이트 하는 suspend 람다, **`ProduceStateScope`** 내에서 실행

간단한 네트워크 통신 예제

```kotlin
@Composable
fun UserProfile(userId: String, viewModel: UserViewModel) { // ViewModel 주입 (예시)
    // userId가 변경되면 produceState 재실행
    val userState: State<User?> by produceState<User?>(
        initialValue = null, key1 = userId
    ) {
        // 생산자 람다: 비동기 작업 수행 및 상태 업데이트
        value = viewModel.fetchUserFromNetwork(userId) // 간단한 네트워크 요청 실행
    }

    // 로딩 상태 또는 사용자 정보 표시
    if (userState == null) {
        Text("Loading...")
    } else {
        Text("User: ${userState?.name}")
    }
}

// 예시 ViewModel 함수
class UserViewModel : ViewModel() {
    suspend fun fetchUserFromNetwork(userId: String): User {
        // 네트워크 지연 시뮬레이션 (실제는 네트워크 통신 로직이 들어가야 함)
        delay(2000)
        return User(name = "skydoves ($userId)") // userId 포함하여 반환
    }
}

data class User(val name: String)
```

1. produceState 를 통해 초기값이 null 인 State<User?> 객체 생성, userId 가 키로 사용되어 userId 가 변경되면 코루틴 재시작
2. 비동기 로직인 생산자 코루틴(여기선 람다식 안의 내용) 은 사용자 데이터를 비동기적으로 가져와 Compose 상태로 만들고 해당 상태 값인 value 업데이트
3. value 가 변경되면 UserProfile 컴포저블이 recompose 되어 업데이트된 데이터 반영

**주요 이점**

- 선언적: 비동기 작업을 실행하고 그 결과를 Compose 상태로 만드는 방식이 Compose 선언적 방식과 동일합니다.
- 컴포지션 생명주기 인지: 컴포저블이 컴포지션을 떠날때 자동으로 코루틴을 취소해 리소스 누수 위험을 방지합니다.
- 유연성: 외부 suspend 함수와 잘 작동하고 키가 변경될 때 코루틴 작업을 다시 시작할 수 있습니다.

해당 produceState 를 사용하기 위해서는 의미있는 keys 값을 사용하는 것이 중요하다. 코루틴 디스 패처를 사용하지 않으면 기보적으로 메인스레드에서 동작함을 유의해야한다.

### 실전 질문

Q) 컴포저블 함수에서 코루틴 작업을 시작하고 그 결과를 상태로 관찰해야 하는 시나리오에서 LaunchedEffect나 rememberCoroutineScope를 사용하지 않고 구현하는 방법에 대해 설명해 주세요.