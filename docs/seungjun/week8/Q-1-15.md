# Q) 15. 컴포저블 함수 내에서 발생하는 사이드 이펙트를 어떻게 처리하나요?

### LaunchedEffect

`LaunchedEffect` 는 컴포저블의 컴포지션 생명주기 내에서 새로운 코루틴 스코프를 생성하고 실행합니다. 전달된 키(key) 가 변경되면 해당 코루틴은 취소되고 새로 다시 시작됩니다.

즉. 컴포저블이 컴포지션에 진입해야할 때 수행해야할 데이터 로딩, 애니메이션 시작 또는 이벤트 수신과 같은 작업에 유용합니다.

동작 예시

- 컴포저블이 컴포지션에 진입시 한번 실행
- 키가 변경되면 자동으로 코루틴 취소 후 다시 시작
- 컴포지션 생명주기 인지, 컴포저블이 종료되면 코루틴 작업이 자동으로 취소

아이템 클릭시 해당 아이템의 id 값으로 가져오는 네트워크 처리

```kotlin
var selectedPoster: Poster? by remember { mutableStateOf(null) }

LaunchedEffect(key1 = selectedPoster) {
    selectedPoster?.let { poster ->
        viewModel.fetchPosterDetails(poster.id)
    }
}
```

해당 방식으로 사용하면 Key 값이 변경되면, 해당 side effect 를 실행합니다.

만약, 컴포저블의 생명주기에 일치하도록 동작하게 하고 싶다면, key Unit 또는 true 와 같은 상수 값을 성정해서 컴포지션이 일어날 때 한번만 실행되도록 합니다.

### DisposableEffect

`DisposableEffect` 는 컴포저블이 사라질 때 호출되는 사이드 이펙트 API 로,

주로 리소스 해지 및 실행 중인 태스크를 정리하기 위해 사용합니다.

내부에 `DisposableEffectScope` 를 선언하고 `onDispose` 람다를 통해 해지합니다.

애널리틱스 관련 이벤트를 보낼때, LifecycleObserver 리소스를 정리하는 예

```kotlin
@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () ‑> Unit, // 'started' 분석 이벤트 전송
    onStop: () ‑> Unit // 'stopped' 분석 이벤트 전송
) {
    // 새 람다가 제공될 때 현재 람다를 안전하게 업데이트
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)
    
    // `lifecycleOwner`가 변경되면 사이드 이펙트를 폐기하고 재설정
    DisposableEffect(lifecycleOwner) {
		    // 람다를 트리거하는 관찰자 생성
		    val observer = LifecycleEventObserver { _, event ‑>
		        if (event == Lifecycle.Event.ON_START) {
		            currentOnStart()
		        } else if (event == Lifecycle.Event.ON_STOP) {
		            currentOnStop()
		        }
		    }
		    
		    // 생명주기에 관찰자 추가
		    lifecycleOwner.lifecycle.addObserver(observer)
			  
			  // 컴포지션을 떠날 때 관찰자 제거
			  onDispose {
			      lifecycleOwner.lifecycle.removeObserver(observer)
			  }
    }
}
```

### SideEffect

`SideEffect` 는 매 recompositon 직후에 적용해야 하는 작업을 실행하는데 사용

컴포저블이 **recompose 가 완료 된후 실행을 보장**하기에 viewmodel 이나 외부 라이브러리 UI 상태 업데이트와 같이 컴포지션의 일부가 아닌 **외부 시스템과 Compsoe 상태를 동기화** 하는데 적합

recomposition 이 완료된후 Lottie 애니메이션 시작하는 경우,

```kotlin
// LottieAnimationView 인스턴스가 있다고 가정
val lottieAniamtionView = rememberLottieAnimationView()

SideEffect {
    // 최신 recomposition 트리거 후에만 애니메이션 재생
    lottieAnimationView.playAnimation()
}
```

### 실전 질문

Q) LaunchedEffect는 컴포저블에서 suspend 함수를 관리하는 데 어떤 도움이 되며, 키 매개변수 값이 변경되면 어떤 동작이 발생하나요?

**키(key) 매개변수의 동작**

- `LaunchedEffect(key)`는 **key 값이 처음 Composition에 들어올 때 코루틴을 시작**합니다.
- 이후 **key 값이 변경되면**:
    1. **기존에 실행 중이던 코루틴을 자동으로 취소(cancel)** 하고
    2. **새로운 코루틴을 다시 실행**합니다.
- key가 변경되지 않으면 **리컴포지션이 발생해도 재실행되지 않습니다.**

즉, `LaunchedEffect`는 **key를 기준으로 코루틴의 실행/취소를 자동 관리**합니다.

Q) LaunchedEffect 대신 DisposableEffect를 사용해야 하는 경우는 언제인가요?

`DisposableEffect`는 suspend 함수 실행이 아닌, 리스너·콜백 등 **외부 리소스를 등록하고 반드시 해제해야 하는 경우**에 사용합니다.

Q) SideEffect의 사용 사례를 설명하고 LaunchedEffect와 어떻게 다른지 설명해 주세요.

`SideEffect`는 **Composable이 리컴포지션을 성공적으로 마친 직후**,

**매번 실행되어야 하는 동기적인 부작용**을 처리할 때 사용합니다.

주로 **Compose 외부 상태를 UI 결과와 동기화**하는 용도로 쓰입니다.

---

**SideEffect 사용 사례**

- 시스템 UI 상태 변경
    - 상태바 / 네비게이션 바 색상 설정
- Activity, Window, System UI 속성 갱신
- Compose 외부 객체에 **현재 UI 상태를 즉시 반영**해야 할 때
- View 기반 라이브러리나 SDK에 상태 전달
