# Q) 16. rememberUpdatedState는 왜 사용하고 어떻게 작동하나요?

`rememberUpdatedState` 함수는 컴포지션 컨텍스트 내 람다 함수에 대한 상태 업데이트를 안전하게 처리하는 런타임 API

**동작 구조**

`rememberUpdatedState` API 는 상태의 가장 최근 값을 기억하고 상태가 변경될 때마다 업데이트 합니다. 컴포저블 또는 람다 내에서 값을 읽고 가장 최신 상태를 반영하는 State<T> 객체를 반환합니다.

```kotlin
@Composable
fun <T> rememberUpdatedState(newValue: T): State<T>
```

**사용 사례**

1. 콜백이 사이드 이펙트 내부로 전달시

   사이드 이펙트 내에서 람다나 콜백이 최초 컴포지션을 통해 생성되었지만, 지속적으로 새로 업데이트 된 람다 및 콜백을 실행해야할 때 유용

2. 애니메이션 또는 사이드 이펙트 API

   recomosition 외에도 지속되는 LaunchedEffect, DisposableEffect 또는 애니메이션과 함께 사용할 때 유용


타이머 콜백 업데이트 예제

```kotlin
@Composable
fun TimerWithCallback(
    onTimeout: () -> Unit, // 시간 초과시 호출될 콜백
    timeoutMillis: Long = 5000L // 타임 아웃 시간 (밀리초)
) {
    // onTimeout 콜백의 최신 버전 기억
    val currentOnTimeout by rememberUpdatedState(onTimeout)
    
    // TimerWithCallback 의 생명주기와 일치하는 효과 생성
    // TimerWithCallback 이 recompose 되더라도 딜레이가 다시 시작되지 않음
    LaunchedEffect(true) { // key 를 true로 설정하여 한 번만 실행
        delay(timeoutMillis) // 딜레이가 발생하는 동안 `onTimeout`의 구현체가 바뀌는 경우
        currentOnTimeout()   // 최신으로 업데이트 된 콜백이 사용되도록 보장
    }
    
    Text(text = "Timer running for $timeoutMillis milliseconds")
}
```

타이머가 실행되는 동안에 컴포지션이 실행 될 당시 구현체 값이 캡처되어,

`onTimeout` 콜백 구현체가 변경되어도, 이전 콜백이 호출될 수 있다.

따라서 이를 콜백 구현체가 변경 되면, 콜백을 최신 상태로 업데이트 하기위해

`rememberUpdatedState` 를 사용해 예방할 수 있다.

**주요 이점**

- 오래된 상태 방지: 장기적인 작업을 수행하는 사이드 이펙트에서 오랜 참조로 인한 문제 방지, 콜백 최신화 등
- 안전한 리컴포지션 처리: SideEffct API 내에서 원활한 처리를 도와줌
- 간단한 통합: 최신 값을 반영하기 위하여 단순히 rememberUpdatedState 로 감싸주기만 하면 됌.

### rememberUpdatedState 내부 구조

```kotlin
@Composable
public fun <T> rememberUpdatedState(newValue: T): State<T> =
    // remember 를 사용해 State 객체를 생성하고 기억
    remember { mutableStateOf(newValue) }
    // 매 리컴포지션 마다 최신 newValue 로 State 값을 업데이트
    .apply { value = newValue }
```

### 실전 질문

Q) LaunchedEffect를 사용하여 어느 정도의 딜레이 이후 람다 함수를 트리거하는 경우에 최신 상태를 반영하는 람다가 호출되도록 어떻게 보장할 수 있나요?

`rememberUpdatedState` 로 람다를 업데이트하여 리컴포지션 마다 새 값으로 업데이트 되게 합니다.