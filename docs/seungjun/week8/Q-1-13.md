# Q) 13. remember와 rememberSaveable의 차이점은 무엇인가요?

### remember

목적: 메모리에 값을 저장하고 recomposition 시 메모리에 저장된 값을 꺼내 상태를 유지

사용: 구성 변경 후에 데이터가 날라가도 되는 상태에 사용, 애니메이션이나 임시적 UI 상태

내부 구조

```kotlin
@Composable
public inline fun <T> remember(crossinline calculation: @DisallowComposableCalls () -> T): T =
    currentComposer.cache(false, calculation)
    
@ComposeCompilerApi
public inline fun <T> Composer.cache(invalid: Boolean, block: @DisallowComposableCalls () -> T): T {
    @Suppress("UNCHECKED_CAST")
    return rememberedValue().let {
        if (invalid || it === Composer.Empty) {
            val value = block()
            updateRememberedValue(value)
            value
        } else it
    } as T
}
```

Compose 컴파일러 플러그인 API(`updateRememberedValue`) 를 호출하여 컴포지션 데이터 값을 캐시합니다.

값이 유효하지 않거나, 초기화 되지 않았는지 확인하고 초기화되지 않았으면 블록 람다 함수를 사용해 값을 계산하고 컴포지션 데이터에 저장한 다음 반환합니다.

### rememberSaveable

목적: 구성 변경시에도 상태를 유지하여 더 넓은 범위에서 상태를 저장하고 복원, `SDK 의 Bundle` 에 저장할 수 있는 값에 한해 자동으로 저장하고 복원

사용: 유저 인풋 입력이나 네비게이션 상태와 같이 구성 변경 후에도 유지되어야 하는 상태에 사용

- 복잡한 객체에 대해 커스텀 Saver 를 지원합니다.

내부구조

```kotlin
@Composable
public fun <T : Any> rememberSaveable(
    vararg inputs: Any?, // 상태 재계산 트리거 하기 위한 입력 키
    saver: Saver<T, out Any> = autoSaver(), // 상태 저장 및 복원 로직
    key: String? = null, // 상태 저장을 위한 고유 키
    init: () -> T, // 초기값 계산 람다
): T {
    val compositeKey = currentCompositeKeyHashCode
    // key is the one provided by the user or the one generated by the compose runtime
    val finalKey =
        if (!key.isNullOrEmpty()) {
            key
        } else {
            compositeKey.toString(MaxSupportedRadix)
        }
    @Suppress("UNCHECKED_CAST") (saver as Saver<T, Any>)

    val registry = LocalSaveableStateRegistry.current

    val holder = remember {
        // value is restored using the registry or created via [init] lambda
        val restored = registry?.consumeRestored(finalKey)?.let { saver.restore(it) }
        val finalValue = restored ?: init()
        SaveableHolder(saver, registry, finalKey, finalValue, inputs)
    }

    val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
    // 리컴포지션 시 상태 업데트 및 레지스트리 등록
    SideEffect { holder.update(saver, registry, finalKey, value, inputs) }

    return value
}
```

1. 키 생성: key 매개변수를 통해 사용자가 커스텀 키를 제공할 수 있다. 커스텀 키가 없으면 현재 컴포지션 해시를 사용해 복합 키가 자동으로 생성된다.

    ```kotlin
    val compositeKey = currentCompositeKeyHashCode
        // key is the one provided by the user or the one generated by the compose runtime
        val finalKey =
            if (!key.isNullOrEmpty()) {
                key
            } else {
                compositeKey.toString(MaxSupportedRadix)
            }
    ```

2. 상태 복원: `LocalSaveableStateRegistry` 는 주어진 키에 대해 이전에 저장된 값이 있는지 확인 후, 값이 존재하면 Saver 를 통해 복원된다.

    ```kotlin
    val registry = LocalSaveableStateRegistry.current
    val restored = registry?.consumeRestored(finalKey)?.let { saver.restore(it) }
    ```

3. 기본값 초기화: 복원된 값이 없으면 init 람다를 통해 기본값이 초기화 된다.

    ```kotlin
    val finalValue = restored ?: init()
    ```

4. Saveable Holder: 상태, saver, 레지스트리 및 입력을 관리하기 위해 SaveableHolder 가 생성된다.

    ```kotlin
    SaveableHolder(saver, registry, finalKey, finalValue, inputs)
    ```

5. 입력 변경 처리: `rememberSaveable` 에 대한 입력이 변경되면 상태가 무효화 되고 값이 다시 초기화 된다.

    ```kotlin
    val value = holder.getValueIfInputsDidntChange(inputs) ?: init()
    ```

6. 사이드 이팩트: SideEffect 를 통해 리컴포지션 시 업데이트된 상태가 레지스트리에 저장된다.

    ```kotlin
    SideEffect { holder.update(saver, registry, finalKey, value, inputs) }
    ```


기본적으로 `LocalSaveableStateRegistry` 를 통해 구성 변경시에도 상태를 보존하게 하는 구조이다.

### 실전 질문

Q) remember이 아닌 rememberSaveable를 사용해야하는 시나리오는 무엇이며, 어떤 트레이드오프를 고려해야 하나요?

기본적으로 rememberSaveable 은 초기화 및 직렬화 역직렬화 로직이 추가적으로 들어가기에 해당 리소스를 remember 보다는 더 많이 가져간다고 볼수 있습니다. 따라서 사용자 입력과 같이 데이터를 구성 변경시 잃어버리지 않게 하기 위해서 사용하고, 그외 중요하지 않는 데이터(잃어도 되는 데이터는) remember 로 가볍게 관리하는것이 좋습니다.

Q) 기본적으로 지원되지 않는 커스텀 비원시(non‑primitive) 값 로 저장하려면 어떻게 해야 하나요?

`rememberSaveable` 은 기본적으로 **Bundle에 저장 가능한 타입만** 지원하기 때문에,

커스텀 비원시 타입은 **직접 저장·복원 방법을 정의한 `Saver`를 구현해 사용** 합니다.