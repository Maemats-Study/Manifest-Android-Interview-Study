# Q) 52. DataBinding의 동작 원리에 대해서 설명해주세요.
DataBinding은 XML 레이아웃의 UI 컴포넌트를 앱의 데이터 소스에 직접 바인딩할 수 있는 안드로이드 라이브러리

UI 디자인에서 선언적 프로그래밍을 부분적으로 가능하게 합니다.

### DataBinding 활성화
build.gradle(app 수준) 에 다음 추가
```kotlin
android {
    ...
    buildFeatures {
        dataBinding = true
    }
}
```
### DataBinding 작동방식
`<layout>` 태그를 사용하는 각 XML 레이아웃에 대한 바인딩 클래스를 생성합니다.
해당 클래스는 뷰에대한 직접적인 접근 및 표현식을 사용해 XML 에서 직접 데이터를 바인딩할 수 있게 하게 합니다.

<details>

<summary>DataBinding 코드</summary>

```xml
<!-- activity_main.xml -->
<?xml version="1.0" encoding="utf‑8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android" 
        xmlns:app="http://schemas.android.com/apk/res‑auto">
    <data>
        <variable 
                name="vm" 
                type="com.example.myapp.ui.UserViewModel" /> <!‑‑ ViewModel 클래스 경로 ‑‑>
    </data>
    <LinearLayout 
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:orientation="vertical"
            android:padding="16dp">
        <TextView 
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{vm.user.name}" /> <!‑‑ 단방향 바인딩 ‑‑>
            
        <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@{String.valueOf(vm.user.age)}" /> <!‑‑ 정수를 문자열로 변환 ‑
            
        <EditText
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:hint="Enter name"
                android:text="@={viewModel.input}" /> <!‑‑ 양방향 바인딩 ‑‑>
            
        <Button
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Update User"
                android:onClick="@{() ‑> viewModel.updateUser(vm.user)}" /> <!‑‑ 이벤트 바인딩 ‑‑>
    </LinearLayout>
</layout>
```

```kotlin
// MainActivity.kt
class MainActivity : AppCompatActivity() { 
    // ViewModel 인스턴스 (예: Hilt 또는 ViewModelProvider 사용) 
    private val viewModel: UserViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) { 
        super.onCreate(savedInstanceState)
        // DataBindingUtil을 사용하여 레이아웃 설정 및 바인딩 객체 가져오기
        val binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main)

        // 바인딩 변수에 ViewModel 및 데이터 모델 설정 
        binding.viewModel = viewModel
        
        // LifecycleOwner 설정 (LiveData 바인딩 등에 필요)
        binding.lifecycleOwner = this
    }
}

// 예시 User 및 ViewModel
data class User(val name: String, val age: Int)

class UserViewModel : ViewModel() {
    private val _user = MutableLiveData<User>(User("Alice", 25))  // 사용자 데이터용
    val user: LiveData<User> = _user

    // input MutableLiveData가 EditText와 양방향 바인딩되어 있으므로
    // EditText 내용이 변경되면 input 값이 자동으로 업데이트됩니다.
    val input = MutableLiveData<String>() // 양방향 바인딩용
   
    fun updateUser(user: User?) {
        // 사용자 업데이트 로직 (예시)
        Log.d("DataBinding", "Update user clicked for: ${user?.name}")
        _user.value?.let { currentUser ‑>
            val updatedUser = currentUser.copy(name = user?.name.orEmpty())
            _user.value = updatedUser
        }
    }
 }
```
</details>

### DataBinding 특징
1. 양방향 데이터 바인딩
2. 바인딩 표현식: 문자열 연결 또는 조건문과 같은 간단한 로직 사용 가능
3. 생명주기 인식(LiveData, StateFlow 와 같이 사용할 때)

### DataBinding 장점
- 보일러 플레이트 코드 감소
- 실시간 UI 업데이트
- 선언적 UI
- 테스트 용이성 향상

### DataBinding 단점
- 성능 오버헤드: ViewBinding 과 같은 더 가벼운 솔루션에 비해 런타임 오버해드 발생
- 복잡성
- 학습 곡선

### 실전 질문
Q) DataBinding과 ViewBinding의 주요 차이점은 무엇이며, 어떤 시나리오에서 각각을 선택하는 것이 좋을까요?
간단한 프로젝트에서 findViewById 없이 간단한 뷰 참조가 필요할 때는 ViewBinding을 사용합니다.
복잡한 데이터 기반 UI 또는 MVVM 아키텍처에서 작업할 때는 DataBinding이 더 효율적인 상황이 많습니다.
동적 바인딩 기능을 제공하고 LiveData, StateFlow 및 @Bindable 어노테이션을 통해 관찰 가능한 속성 또는 메서드를
커스텀하여 구현할 수 있기 때문입니다. 따라서, DataBinding은 더 다양한 기능들을 제공하지만 추가 오버헤드가 발생할 수 있으므로,
ViewBinding 사용만으로도 충분한 간단한 프로젝트에는 필요하지 않을 수 있습니다.

Q) MVVM 아키텍처에서 DataBinding은 어떤 역할을 하며, 안드로이드 개발에서 UI 로직과 비즈니스 로직을 분리하는 데 어떻게 활용할 수 있나요?
