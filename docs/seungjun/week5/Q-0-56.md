# Q) 56: Dagger 2와 Hilt의 동작원리 및 차이점에 대해서 설명해 주세요.

의존성 주입 라이브러리에는 Dagger2 와 Hilt 가 가장 대표적으로 사용합니다.<br/>
두 라이브러리 모두 Google 에서 개발하고 공식적으로 지원 할 뿐만 아니라,
대규모 프로젝트에서 사용성이 많이 검증되었기 때문입니다.

### 수동 의존성 주입


### Dagger 2란?
안드로이드 JVM 환경을 위한 정적 컴파일 타임 기반의 의존성 주입(DI) 라이브러리

객체 생성을 관리하고 의존성을 자동으로 제공합니다.
컴파일 타임에 코드를 생성해, 리플렉션 기반 DI 프레임워크에 비해 더 나은 성능을 보장합니다.

### Hilt 란?
Dagger2 기반 구축된 안드로이드 전용 의존성 주입 라이브러리

Activity, Fragment, ViewModel 과 같이 안드로이드 생명주기와 밀접한 관련이 있는 클래스에 스코프가
지정된 사전 정의 컴포넌트를 제공합니다. Dagger 의 보일러 플레이트를 줄여 단순화 시켰습니다.

Hilt 는 `@HiltAndroidApp` 및 `@AndroidEntryPoint`와 같은 어노테이션을 제공하여
DI 설정을 간소화해 Dagger 2 에 필요한 많은 보일러 플레이트 코드를 제거합니다.<br/>
또한 `@Singleton` 및 `@ActivityScoped`와 같은 범위를 정의해 의존성 생명주기를 관리합니다.

```kotlin
@HiltAndroidApp // Hilt 사용을 위한 Application 클래스 어노테이션
class MyApplication : Application()

@AndroidEntryPoint // Hilt 가 의존성을 주입할 Activity
class MainActivity : AppCompatActivity() {
    @Inject // Retrofit 의존성 주입 요청
    lateinit var retrofit: Retrofit
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // Hilt가 자동으로 의존성 주입 처리
    }
}

@Module
@InstallIn(SingletonComponent::class) // 모듈이 설치될 컴포넌트 지정 (앱 전체 범위)
object NetworkModule {
    @Provides
    fun provideRetrofit(): Retrofit {
        return Retrofit.Builder()
            .baseUrl("https://example.com")
            .build()
    }
}
```

### Dagger2 vs Hilt
1. 통합 프로세스:<br/>
Dagger2는 개발자가 컴포넌트와 인젝트를 수동으로 정의해야하는 단점<br/>
but, Hilt 는 사전 정의된 컴포넌트와 생명주기에 스코핑 된 어노테이션 제공해 이를 단순화
2. 안드로이드 생명주기 통합:<br/>
Hilt 는 안드로이드에 특화되어 있어 Activity, Fragment, ViewModel 과 같은 안드로이드 컴포넌트에
대한 내장 지원을 제공<br/>
이에 반해 Dagger2 는 더 범용적이며 생명주기 인식 컴포넌트에 대한 수동적 설정 필요
3. 스코핑(Scoping):<br/>
Hilt 는 안드로이드 생명주기 클래스와 밀접하게 통합된 사전 정의된 Scope 제공<br/>
Dagger2 는 스코핑에 수동 설정 및 커스텀 어노테이션 필요
4. 코드 단순성:<br/>
Hilt 는 많은 보일러 플레이트 코드를 추상화해 DI 설정의 보잡성을 줄여 쉽게 사용 가능<br/>
Dagger2 는 복잡한 구조에서 더 세밀하게 사용할 수 있지만, 개발자가 모든 컴포넌트와의 관계를 수동의로 정의해야함
5. 사용 사례:<br/>
Dagger2 는 복잡하고 커스텀된 의존성 주입 그래프가 필요한 프로젝트에 적합<br/>
Hilt 는 안드로이드 프로젝트시 사용 평의성과 안드로이드 컴포넌트 통합헤 중점을 둠.

### Dagger2, Hilt 어노테이션

1. @Inject : 의존성 주입을 요청, 의존성 주입을 위해 생성자, 필드 또는 메스드에 표시
2. @Provides: `@Module` 내에서 의존성 생성 메서드를 정의 합니다.(객체 제공)
3. @Module: 클래스를 의존성 제공자 컨테이너로 선언합니다. 모듈은 관련된 의존성 생성 로직을 그룹화 합니다.
4. @Binds: `@Module` 내에서 인터페이스를 구현에 매핑하는 데 사용되어 의존성 정의 시 보일러 플레이트 코드를 줄입니다.
5. @Qualifier: 커스텀 어노테이션을 사용해 동일한 ㅇ타입에 대해 여러 의존성 바인딩 구별
6. @Scope: 특정 의존성의 생명주기를 제어하기 위해 커스텀 스코핑 어노테이션을 정의할 수 있습니다.
7. @Singleton: 의존성이 해당 범위 내내 단위 공유 인스턴스를 가져야 함을 지정
8. @Component: 의존성 그래프의 인터페이스를 정의
9. @Subcomponent: 지정 범위 내 의존성을 관리하기 위한 케이스를 위해 @Component 내 더작은 의존성 그래프를 생성합니다.

### Hilt 특화 어노테이션
1. @HiltAndroidApp: Hilt 를 부트스트랩하고 전체 앱에 대한 의존성 그래프를 생성하기 위해 사용<br/>
Application 클래스에 사용하고, Hilt 를 초기화 하기 위한 필수 어노테이션
2. @AndroidEntryPoint: 안드로이드 컴포넌트를 주입 대상으로 마킹<br>
이를 통해 커스텀 Dagger 컴포넌트를 정의할 필요가 없습니다.
3. @InstallIn: `@Module` 이 설치되어야 하는 컴포넌트(SingletonComponent, ActivityComponent)를 지정합니다.
4. @EntryPoint: Hilt 에서 관리하는 안드로이드 컴포넌트가 아닌 ㅇ외부 의전성에 접근하기 위한 진입점 정의하기 위해 사용
5. @HiltViewModel: Jatpack ViewModel 을 Hilt 와 통합하기 위한 특수 어노테이션<br/>
ViewModel 이 생명주기를 인식하면서 Hilt 의 의존성 주입을 사용할 수 있도록 보장<br/>
`@HiltViewModel` 어노테이션은 생성자에 `@Inject`와 함께 사용해야합니다.
6. Scope Annotations: 사용자가 컴포넌트를 수동의로 정의, 인스턴스 하는 Dagger 와 다르게 
Hilt 는 사전 정의된 컴포넌트를 사용해 특정 라이프 사이클에 의존성을 바인딩하는 프로세스를 단순화합니다.

### 그외 DI 라이브러리
Koin: 가볍고 사용하기 쉬운 DI 라이브러리
- 어노테이션 처리 없음
- Kotlin DSL 을 사용한 DI 구성
- 사용 편의성: 설정 등이 빨라 소규모 프로젝트에 이상적
- 동적 해결: 런타임시에 의존성이 결정 됨. -> 빌드 성능 우선시에 유리
- KMP 지원
- 서비스 로케이터 패턴

Anvil: Dagger2 기반 컴파일러 플러그인
- Dagger 의 모듈 생성 보일러 플레이트 코드를 단순화 함.
- 특정 컴포넌트 어노테이션 프로세싱 오버헤드를 줄여 빌드 시간을 크게 개선
Dagger 기반 코드에서 모듈과 인터페이스를 자동 병합 하는 기능만 사용하고자 할때 좋은 대안이 될 수 있음.

- Koin은 소규모 프로젝트나 DI를 빠르게 셋업 하여 프로젝트에 적용하고 싶은 경우,
또는 어노테이션 처리 없이 간단하게 DI를 사용하고자 하는 경우 좋은 선택입니다.
- Anvil은 이미 대규모 프로젝트에서 Dagger를 사용하고 있으며,
기존 Dagger 컴포넌트와의 호환성을 유지하면서 워크플로를 단순화하려는 상황에 가장 적합합니다.

### 실전 질문
Q) Dagger 2와 비교하여 의존성 Hilt는 주입을 어떻게 단순화하고,
안드로이드 애플리케이션에서 Hilt를 사용하는 것의 장점은 무엇인가요?

Q) Dagger와 Hilt에서 @Provides와 @Binds의 차이점은 무엇이고, 각각 언제 사용해야 하나요?
@Binds 주석은 인터페이스의 인스턴스를 제공해야할 때 사용합니다.
@Provides 는 외부라이브러리처럼 직접 객체를 생성해야하는 경우에 사용합니다.

@Binds 는 컴파일 타임에 인터페이스 타입 요청시 지정된 구현체 클래스를 연결해주는 방식으로 작동합니다. 이에반에
@Provides 는 런타임에 실제 메서드 호출을 통해 객체를 생성하는 구조입니다.

Q) Hilt에서 @Singleton, @ActivityScoped, @ViewModelScoped를
사용하면 내부적으로 스코핑이 어떻게 작동하는지 매커니즘을 설명하고,
해당 스코프가 사용되면 애플리케이션 내 의존성의 수명을 어떻게 관리하는지 설명해 주세요.