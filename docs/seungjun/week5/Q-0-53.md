# Q) 53. LiveData에 대해서 설명해 주세요.

LiveData 는 안드로이드 Jetpack 아키텍처 컴포넌트에서 제공하는 관찰 가능한 데이터 홀더 클래스
생명주기를 인식해 LiveData 연관 컴포넌트가 활성 상태 주기(ex. started, resumed) 일 때만
데이터를 관찰하고 UI 를 업데이트 하도록 보장합니다.

주요 목적은 UI 컴포넌트가 데이터 변경사항을 관찰하고 데이터 변경이 될 때만 반응형형으로 업데이트 할수 있도록 구현합니다.

### LiveData 장점
1. 생명주기 인식
2. 자동 정리: 컴포넌트에 연결된 observer 는 주어진 생명주기가 소멸될 때 자동으로 제거되고 정리됩니다.
3. 관찰자 패턴(Observer Pattern): Observer 를 활용해 LiveData 의 데이터가 변경될 때 자동으로 업데이트 됩니다.
4. 스레드 안전성: LiveData 는 스레드에 안전하도록 설계되어 백그라운드 스레드에서 업데이트 할 수 있습니다.

<details>

<summary>LiveData 코드</summary>

```kotlin
// LiveData Example
// ViewModel
class MyViewModel : ViewModel() { 
    // 내부 수정을 위한 MutableLiveData
    private val _data = MutableLiveData<String>()
    // 외부 수정을 방지하기 위해 LiveData로 노출
    val data: LiveData<String> get() = _data
    
    fun updateData(newValue: String) {
        // LiveData 값 업데이트
        _data.value = newValue
     }
}

// Fragment 또는 Activity
class MyFragment : Fragment() {
    private val viewModel: MyViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
    
        // LiveData 관찰
        viewModel.data.observe(viewLifecycleOwner) { updatedData ‑>
            // 새 데이터로 UI 업데이트
            textView.text = updatedData
        } 
    }
}
```
</details>

### LiveData vs Flow
Flow 와 LiveData 의 가장 큰 차이점은 Flow 는 안드로이드와 독립적인 API 로
안드로이드 컴포넌트에 대한 수명주기를 알지 못합니다.

따라서 Flow 는 collect 및 구독 해지를 안드로이드 라이프 사이클에 따라 올바르게 하지 않으면,
화면이 활성 상태가 아닌 상태에도 데이터를 수집하는 등의 메모리 누수로 이어질 가능성이 높습니다.

반면 LiveData 는 구독 시점에 애초에 lifecycle 인스턴스를 결합하여, 개발자가 적절한 시기에
구독해지를 해주지 않아도 생명주기에 따라 안전하게 데이터를 수집하기 때문에 상황에 따라 LiveData를 활용하는 편이 더 올바른 선택이 될 수 도 있습니다.

###
Q) LiveData는 생명주기 인식을 어떻게 보장하며, RxJava 또는
EventBus와 같은 전통적인 observable한 객체와 비교하여 어떤 이점을 제공하나요?

Q) LiveData에서 setValue()와 postValue()의 차이점은 무엇이며,
각각 언제 사용해야 하나요?

Q) LiveData의 한계는 무엇이며, 구성 변경 시 다시 트리거되지 않고
내비게이션 또는 토스트 메시지 표시와 같은 여러 UI 이벤트를 관찰해야하는 경우에 어떻게 처리해야 하나요?
