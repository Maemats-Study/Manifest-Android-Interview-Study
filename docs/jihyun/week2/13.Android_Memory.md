## 안드로이드의 자동 메모리 관리

안드로이드 운영체제는 개발자가 메모리를 직접 관리하는 수고를 덜어주기 위해 두 가지 강력한 시스템을 사용

### 1. 가비지 컬렉션 (Garbage Collection, GC)

가비지 컬렉터(GC)는 앱이 사용하는 메모리(힙 영역)를 계속 감시하다가, 더 이상 아무도 사용하지 않는 객체(쓰레기)를 발견하면 알아서 수거하여 메모리 공간을 확보하는 자동화된 시스템

- **동작 원리:** 앱의 모든 변수와 객체들은 서로를 가리키는 '참조'라는 연결고리를 가지고 있음. GC는 앱의 시작점부터 이 연결고리를 따라가며, 연결이 닿는 모든 객체에 "사용 중"이라는 표시를 함. 표시되지 않은 객체, 즉 어디에서도 참조되지 않는 객체들은 더 이상 필요 없다고 판단하고 메모리에서 제거
- **장점:** 개발자가 C/C++ 언어처럼 `malloc`과 `free` 같은 함수를 이용해 수동으로 메모리를 할당하고 해제하는 복잡하고 실수하기 쉬운 작업을 할 필요가 없어 생산성이 크게 향상됨

### **2. 로우 메모리 킬러 (Low-Memory Killer)**

안드로이드 기기는 PC와 달리 메모리가 제한적. 여러 앱이 동시에 실행되다 보면 시스템 전체 메모리가 부족해지는 상황이 발생할 수 있음. 이때 '로우 메모리 킬러'가 등장

- **동작 원리:** 시스템 메모리가 부족해지면, 로우 메모리 킬러는 현재 실행 중인 프로세스들의 우선순위를 판단하여 가장 중요도가 낮은 프로세스부터 강제로 종료시켜 메모리를 확보.
    
    우선순위는 보통 다음과 같음
    
    1. **포그라운드 앱 (Foreground):** 현재 사용자가 화면에서 직접 상호작용하고 있는 가장 중요한 앱
    2. **가시적 앱 (Visible):** 화면에 보이지만 포커스는 없는 앱 (예: 화면 분할 모드)
    3. **서비스 프로세스 (Service):** 화면은 없지만 백그라운드에서 음악 재생, 파일 다운로드 등을 수행하는 프로세스
    4. **백그라운드 앱 (Background):** 사용자가 이전에 사용했지만 지금은 화면에 보이지 않는 앱
    5. **빈 프로세스 (Empty):** 아무 작업도 하지 않고 캐시 목적으로 유지되는 프로세스

로우 메모리 킬러는 **가장 낮은 우선순위인 빈 프로세스부터** 차례대로 종료시키며, 현재 사용자가 쓰고 있는 포그라운드 앱의 원활한 작동을 보장

## 메모리 누수(Memory Leak)

메모리 누수는 "더 이상 사용하지 않아 버려야 할 객체를 앱이 계속 붙들고 있어서, 가비지 컬렉터가 청소하지 못하는 현상"을 말함. 마치 구멍 난 물통처럼 메모리가 조금씩 새어 나가 결국에는 앱이 사용할 수 있는 메모리가 고갈됨. 이로 인해 앱의 성능이 저하되거나, 심한 경우 `OutOfMemoryError`가 발생하며 앱이 강제 종료될 수 있음

## 메모리 누수를 피하기 위한 8가지 핵심 전략

### 1. 생명주기를 인지하는 컴포넌트 사용

- `ViewModel`, `LiveData`, `Flow` (LifecycleCoroutineScope와 함께 사용 시) 등은 **Activity나 Fragment의 생명주기(생성, 시작, 소멸 등)를 스스로 인지**함.
    
    예를 들어, 화면이 사라져 더 이상 데이터를 보여줄 필요가 없을 때, 이 컴포넌트들은 불필요한 데이터 업데이트를 중단하고 관련 리소스를 자동으로 정리
    
- 사용자가 화면을 회전하면 Activity는 파괴되었다가 다시 생성됨. 만약 데이터를 일반 변수에 저장했다면 데이터가 사라지지만, `ViewModel`에 저장하면 Activity가 재생성되어도 데이터가 그대로 유지됨. 이 과정에서 불필요한 참조를 자동으로 관리해주어 누수를 방지

### 2. Context에 대한 오랜 참조 피하기

- 안드로이드에서 `Context`는 앱의 정보에 접근하거나 시스템 기능을 사용할 때 필수적임. 하지만 `Activity Context`는 해당 Activity의 생명주기에 묶여있어 수명이 짧음. 만약 수명이 긴 객체(예: **싱글톤**이나 **정적(static) 필드**)가 `Activity Context`를 참조하면, Activity가 종료되어도 이 참조 때문에 메모리에서 해제되지 못하고 누수가 발생
- 해결책: 앱 전체의 생명주기와 함께하는 `ApplicationContext`를 사용해야 함
    - 나쁜 예 (Bad Practice):
        
        ```java
        class MySingleton {
            private static Context context; // static 필드가 Activity를 직접 참조하면 매우 위험!
            public static void initialize(Context ctx) {
                context = ctx; // Activity가 전달되면 누수 발생
            }
        }
        ```
        
    - 좋은 예 (Good Practice):
        
        ```java
        class MySingleton {
            private static Context context;
            public static void initialize(Context ctx) {
                context = ctx.getApplicationContext(); // 항상 ApplicationContext를 사용
            }
        }
        ```
        

### 3. 리스너 및 콜백 등록 올바르게 해제하기

- 위치 정보 수신(`LocationManager`), 센서 데이터(`SensorManager`), 브로드캐스트 메시지(`BroadcastReceiver`) 등을 사용하기 위해 리스너를 등록하면, 시스템은 해당 리스너 객체를 계속 참조함. 만약 화면이 사라질 때 이 리스너 등록을 해제하지 않으면, 리스너는 여전히 Activity를 참조하고 있어 메모리 누수가 발생함.
- 실천 방법: 생명주기 메서드에서 짝을 맞춰 등록하고 해제해야 함
    - `onCreate()`에서 등록했다면 `onDestroy()`에서 해제
    - `onStart()`에서 등록했다면 `onStop()`에서 해제
    - `onResume()`에서 등록했다면 `onPause()`에서 해제

### 4. 중요하지 않은 객체는 `WeakReference` 사용하기

- 자바와 코틀린의 참조는 기본적으로 강한 참조(Strong Reference). 강한 참조가 하나라도 남아있으면 GC는 절대 그 객체를 수거하지 못함.
    
    반면, 약한 참조(WeakReference)는 GC가 동작할 때 무시되는 참조. 즉, 어떤 객체를 가리키는 참조가 약한 참조밖에 없다면, GC는 그 객체를 바로 수거할 수 있음.
    
- 사용 시점: 캐시(Cache) 구현이나, 반드시 존재할 필요는 없지만 있으면 사용하는 비동기 작업의 결과 처리 콜백 등에서 유용. 객체가 메모리에서 해제될 수도 있음을 감수해야 할 때 사용함.

### 5. 누수 감지 툴 사용

- 개발자가 모든 누수를 직접 찾아내는 것은 매우 어려움. 다행히 강력한 도구들이 있음
    - **LeakCanary:** 라이브러리를 프로젝트에 추가하기만 하면, 앱 실행 중 메모리 누수가 의심되는 상황을 자동으로 감지하여 알림을 보내줌. 누수의 원인이 되는 참조 경로를 자세히 보여주어 문제 해결을 크게 도움.
    - **Android Studio Memory Profiler:** Android Studio에 내장된 전문가용 도구. 앱의 실시간 메모리 사용량을 그래프로 보여주고, 특정 시점의 메모리 상태(힙 덤프)를 분석하여 어떤 객체가 메모리를 많이 차지하는지, 어떤 객체가 누수를 일으키는지 정밀하게 분석할 수 있음

### 6. View에 대한 정적(static) 참조 피하기

- 이는 2번 규칙의 구체적인 사례입니다. `View` 객체(버튼, 텍스트뷰 등)는 생성될 때의 `Activity Context`를 내부적으로 참조하고 있음. 만약 이 `View` 객체를 정적(static) 변수에 할당하면, 정적 변수는 앱이 종료될 때까지 살아있으므로 `View`도 계속 살아있게 되고, 결국 `View`가 물고 있는 `Activity` 전체가 메모리에서 해제되지 못하는 심각한 누수를 유발.

### 7. 리소스 명시적으로 닫기

- 파일 입출력(`FileInputStream`), 데이터베이스 커서(`Cursor`), 네트워크 연결 등은 안드로이드 메모리가 아닌 별도의 시스템 리소스를 사용. 이런 리소스들은 사용이 끝나면 반드시 `close()` 메서드를 호출하여 시스템에 반납해야 함. 잊어버리고 닫지 않으면 리소스가 계속 열려있어 메모리 누수뿐만 아니라 다른 시스템 문제를 일으킬 수 있음.
- 코틀린의 해결책: `use` 확장 함수를 사용하면 코드가 훨씬 간결하고 안전. `use` 블록이 끝나면 리소스가 자동으로 `close()`됨
    
    ```kotlin
    // 'use'를 사용하면 finally 블록에서 close()를 호출할 필요가 없음
    context.contentResolver.query(uri, ...).use { cursor ->
        // cursor를 사용하는 코드
    }
    ```
    

### 8. Fragment와 View 현명하게 사용하기

- `Fragment`는 `Activity`보다 생명주기가 더 복잡함. 특히 `Fragment`를 백스택(back stack)에 추가하면, `Fragment`의 뷰(View)는 파괴(`onDestroyView()`)되지만 `Fragment` 인스턴스 자체는 메모리에 남아있을 수 있음. 이때 `Fragment`가 자신의 뷰에 대한 참조를 계속 가지고 있다면, 파괴된 뷰가 메모리에서 해제되지 않아 누수가 발생함.
- **해결책:** `onDestroyView()` 콜백 메서드에서 뷰와 관련된 모든 참조를 `null`로 만들어 깨끗하게 정리해야 함. (데이터 바인딩이나 뷰 바인딩 라이브러리는 이를 자동으로 처리해주는 경우가 많음.)

## 더 생각해보기

### **가비지 컬렉션(GC)과 런타임**

- **가비지 컬렉션(GC)은 언제, 얼마나 자주 일어나는지?** 너무 자주 일어나면 앱 성능에 영향을 주지 않는지?
    - GC는 **힙(heap) 메모리가 가득 찼을 때** 주로 발생. 너무 많은 객체가 짧은 시간 안에 생성되고 버려지면 GC가 더 자주 발생하는데, 이를 '메모리 변동(Memory Churn)'이라고 함
    - GC가 실행되는 동안에는 앱의 모든 스레드가 잠시 멈추는 **"Stop-the-World" 현상**이 발생할 수 있음. 이 시간이 길어지면 사용자는 화면이 순간적으로 멈칫하거나 버벅거리는 현상(Jank)을 느끼게 됨. 따라서 불필요한 객체 생성을 최소화하여 GC 발생 빈도를 줄이는 것이 성능 최적화의 핵심.
- Dalvik과 ART 런타임의 가비지 컬렉션 방식에 구체적으로 어떤 차이가 있는지? ART가 더 효율적이라고 하는데 왜 그런가?
    - 가장 큰 차이는 GC 실행 방식과 효율성
    - **Dalvik (안드로이드 5.0 이전):** 한 번에 전체 힙을 검사하고 정리하는 방식이라 "Stop-the-World" 시간이 길었음. (수십~수백 ms)
    - **ART (안드로이드 5.0 이후):** 힙을 여러 세대(Generation)로 나누고, 최근에 생성된 객체들이 모여있는 **'Young Generation'** 영역을 더 자주, 그리고 빠르게 청소. 이 방식은 "Stop-the-World" 시간을 매우 짧게(몇 ms) 줄여주어 앱 성능을 크게 향상시켰음. 또한, 메모리 조각화 문제도 개선되었음.
- 개발자가 직접 가비지 컬렉션을 호출(`System.gc()`)하는 것은 좋은 방법인가? 왜 권장되지 않는지?
    - **절대 권장되지 않음.** `System.gc()`를 호출하는 것은 시스템에 GC를 "요청"하는 것일 뿐, 즉시 실행된다는 보장이 없음. 오히려 시스템의 효율적인 GC 스케줄링을 방해하여 전체적인 성능을 떨어뜨릴 수 있음. 개발자는 GC를 직접 제어하려 하기보다, **불필요한 객체를 만들지 않는 코드**를 작성하는 데 집중해야 함.
- '더 이상 참조되지 않는 객체'를 판단하는 GC의 정확한 기준은 무엇인가? 순환 참조 같은 엣지 케이스는 어떻게 처리하는지?
    - GC는 'GC Root'라고 불리는 특별한 시작점들(예: 실행 중인 스레드, static 변수 등)에서부터 시작하여, 참조 체인을 따라 연결된 모든 객체를 찾아 표시. 이 과정이 끝난 후 **표시되지 않은 모든 객체**는 '닿을 수 없는(unreachable)' 객체로 간주되어 수거 대상이 됨.
    - **순환 참조** (객체 A가 B를 참조하고, B가 다시 A를 참조하는 경우) 자체는 문제가 되지 않음. 만약 이 순환 참조 그룹 전체가 GC Root로부터 연결이 끊어진다면, 그룹 전체가 함께 쓰레기로 간주되어 수거됨.

### 로우 메모리 킬러

- 내 앱이 어떤 **우선순위(Foreground, Background 등)에 있는지 실시간으로 확인**할 수 있는 방법이 있는지?
    - 개발자가 코드 내에서 직접 "현재 내 우선순위는 Background입니다"와 같이 명확히 알 수 있는 API는 없음. 하지만 `ActivityManager.getMyMemoryState(RunningAppProcessInfo)`와 같은 메서드를 통해 현재 프로세스의 상태(예: `IMPORTANCE_FOREGROUND`, `IMPORTANCE_CACHED`)를 간접적으로 확인할 수는 있음. 이를 통해 앱이 백그라운드로 전환될 때 리소스를 정리하는 등의 대응을 할 수 있음.
- 백그라운드에서 중요한 작업을 하고 있을 때, **로우 메모리 킬러에 의해 종료되지 않도록** 하려면 어떻게 해야 하는지?
    - 사용자에게 명확하게 인지되는 작업을 백그라운드에서 수행해야 할 때, `Foreground Service`를 사용해야 함. Foreground Service를 시작하면 시스템은 이 앱이 사용자에게 중요한 작업을 하고 있다고 판단하여 프로세스 우선순위를 매우 높게 유지함. 따라서 메모리가 아무리 부족해도 거의 종료되지 않음. 음악 재생 앱이나 내비게이션 앱이 대표적인 예.
- 로우 메모리 킬러에 의해 내 앱이 종료되었다는 사실을 개발자가 알 수 있는지? 로그나 콜백 같은 것이 있는가?
    - 사용자 입장에서는 그냥 앱이 사라진 것처럼 보임.
    - 개발자는 **Android Studio의 Logcat**에서 `lowmemorykiller`라는 키워드로 로그를 필터링하여 시스템이 어떤 프로세스를 종료시켰는지 확인할 수 있음. 또한, 프로세스가 종료된 후 사용자가 다시 앱을 실행하면 `Application`과 `Activity`의 `onCreate()`가 다시 호출되므로, `onSaveInstanceState()`에 저장된 데이터가 없는 것을 통해 비정상 종료를 추측할 수 있음.

### 메모리 누수 방지 전략

- **`WeakReference`는 정확히 어떤 상황에서 사용해야 가장 효과적인가?** `WeakReference`를 사용했을 때 객체가 너무 빨리 사라져서 문제가 생길 수도 있지 않는지?
    - "이 객체가 없어져도 내 코드는 안전하게 동작해야 한다"는 확신이 있을 때 사용. `WeakReference`로 감싼 객체는 다음 GC 때 언제든지 `null`이 될 수 있기 때문에, 사용하기 전에는 항상 `null` 체크를 해야 함.
    - 가장 대표적인 예시는 비동기 작업 후 결과를 UI에 표시해야 하는 경우. 네트워크 요청 후 결과를 받았을 때, 만약 그 사이 사용자가 화면을 나가서 Activity가 파괴되었다면 UI 업데이트를 시도하면 안 됨. 이럴 때 Activity를 `WeakReference`로 들고 있다가, 결과를 처리하기 직전에 `null`인지 확인하고 `null`이 아닐 때만 UI를 업데이트하면 안전하게 메모리 누수를 방지할 수 있음.
- **LeakCanary는 어떤 원리**로 메모리 누수를 감지하는 건가? 실제 서비스(릴리즈) 버전의 앱에도 포함시켜도 되는지?
    - LeakCanary는 `WeakReference`와 `ReferenceQueue`를 이용하여 동작. Activity가 `onDestroy()` 될 때 해당 Activity 객체를 `WeakReference`로 감싸고 감시를 시작. 잠시 후 강제로 GC를 실행시킨 뒤, 만약 Activity 객체가 메모리에서 수거되지 않고 여전히 남아있다면 (즉, `WeakReference`가 `null`이 되지 않았다면) 어딘가에 강한 참조가 남아있다고 판단하고 메모리 덤프를 떠서 누수 경로를 분석해 알려줌.
    - **릴리즈 버전에는 절대 포함하면 안 됨.** LeakCanary는 누수 분석을 위해 강제 GC 실행, 메모리 덤프 등 시스템에 큰 부하를 주는 작업을 수행하므로 앱 성능에 심각한 영향을 미침. 보통 디버그 빌드에만 포함되도록 설정
- `Fragment`의 `onDestroyView()`에서 뷰 참조를 `null`로 만들어주라고 했는데, **Android Jetpack의 View Binding이나 Data Binding을 사용하면 이 작업을 자동으로 해주는지?**
    - 자동으로 인지해줌. Jetpack의 View Binding과 Data Binding 라이브러리는 Fragment의 생명주기를 인지하도록 설계됨. `Fragment`의 뷰가 생성될 때(`onCreateView`) 바인딩 객체를 생성하고, 뷰가 파괴될 때(`onDestroyView`) 내부적으로 참조를 자동으로 정리(`null` 처리)해줍니다. 이 덕분에 개발자가 수동으로 뷰 참조를 해제하는 코드를 작성하지 않아도 되어, 관련 메모리 누수를 매우 효과적으로 방지할 수 있음.
- **싱글톤(Singleton) 패턴**을 사용할 때 `Context`가 필요하다면, `ApplicationContext`를 전달하는 것 외에 또 주의해야 할 점이 있는지?
    - **스레드 안전성(Thread-Safety):** 여러 스레드에서 동시에 싱글톤 인스턴스에 접근하여 상태를 변경할 경우 데이터가 꼬일 수 있음. `@Synchronized` 어노테이션이나 `volatile` 키워드 등을 사용하여 스레드로부터 안전하게 만들어야 함.
    - **리스너 등록/해제:** 만약 싱글톤이 시스템 서비스에 리스너(예: `BroadcastReceiver`)를 등록한다면, 앱이 종료될 때 반드시 이 리스너를 해제해주어야 함. 그렇지 않으면 앱 프로세스가 종료된 후에도 싱글톤 객체가 메모리에 남아 누수를 일으킬 수 있음.