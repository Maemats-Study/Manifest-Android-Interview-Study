# 상태 호이스팅(state hoisting)으로 어떤 이점을 얻을 수 있나요?

상태 호이스팅(State hoisting)은 상태를 상위 수준의 컴포저블 함수로 끌어올리는 것을 의미

따라서, 상태 값과 상태 값을 업데이트하는 람다 함수를 컴포저블 매개변수로 전달하고 해당 값은 현재 컴포저블이 아닌 다른 호출자 쪽에서 관리하도록 하는 것

상태 호이스팅은 근본적으로 단방향 데이터 흐름 원칙을 따르므로 UI를 더 쉽게 관리하고 확장 가능하게 만듦

### 상태 호이스팅의 특성

- State: 부모 컴포저블에서 관리
    - 상태 호이스팅을 적용하려는 컴포저블은 상태 자체를 가져서는 안 되고, 매개변수로 상태를 받아서도 안 됨
- Events 또는 triggers
    - 자식에서 값을 바꾸고, 해당 값을 부모로 다시 전달받는 형태로 상태를 업데이트
    - 보편적으로 람다 함수를 매개변수로 넘기고, 해당 컴포저블을 호출하는 쪽에서 업데이트된 값을 콜백으로 받아 상태를 업데이트시키는 형태로 동작
- 업데이트된 상태는 매개변수로 자식에게 다시 전달되어 단방향 데이터 흐름을 생성

### 상태 호이스팅의 장점

- 더 나은 재사용성
    - 상태 호이스팅을 적용하면 컴포저블을 상태 없는 형태(stateless) 및 재사용 가능하게 만들 수 있음
    - 상태 및 이벤트 콜백을 전달 → 동일한 컴포저블을 특정 구현에 얽매이지 않고 다른 화면이나 컨텍스트에서 사용할 수 있음
- 단순화된 테스트
    - 상태를 저장하지 않는 컴포저블은 매개변수로 전달된 상태 값에 전적으로 의존 → 테스트하기가 더 쉬움
    - 이로 인해 예측 가능하고 명확한 테스트 시나리오 가능
- 더 나은 관심사 분리
    - 상태 관리 로직을 부모 컴포저블 또는 ViewModel로 옮김으로써, UI 컴포넌트가 인터페이스 렌더링에만 집중하도록 함
    - 이러한 역할 분리는 비즈니스 로직과 UI 코드를 구별하여 유지 관리성을 향상
- 단방향 데이터 흐름 지원
    - 상태 호이스팅은 Jetpack Compose의 단방향 데이터 흐름 아키텍처와 일치하여 상태가 단 하나의 공급원에서 흐르도록 보장
    - 여러 소스가 동일한 상태를 관리하려고 할 때 발생하는 예상치 못한 동작의 발생 가능성을 줄임
- 향상된 상태 관리
    - 상태 호이스팅을 사용하면 ViewModel 또는 부모 컴포저블과 같은 상위 수준 컨테이너에서 상태를 중앙 집중화할 수 있음
    - 이를 통해 복잡한 UI 흐름을 관리하고 인스턴스 상태 저장 또는 상태 복원 관리와 같은 작업을 더 쉽게 처리할 수 있음