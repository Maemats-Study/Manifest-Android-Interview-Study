# Q3) Serializable 과 Parcelable 의 차이점

## Serializable

• Java 표준 인터페이스 (Java Standard Interface): Serializable은 객체를 바이트 스트림으로 변환하여 Activity 간에 전달하거나 디스크에 쓸 수 있도록 하는 표준 Java 인터페이스입니다.
• 리플렉션 기반 (Reflection‑Based): Java 리플렉션을 통해 작동 합니다. 즉, 시스템이 런타임에 클래스와 필드를 동적으로 검사 하여 객체를 직렬화합니다.
• 성능: Serializable은 리플렉션이 느린 프로세스이기 때문에 Parcelable에 비해 느립니다. 또한 직렬화 중에 많은 임시 객체를 생성하여 메모리 오버헤드를 증가시킵니다.
• 사용 사례: Serializable은 성능이 중요하지 않거나 안드로이드 특정 코드가 아닌 코드베이스를 다룰 때 유용합니다

```kotlin
@Serializabledata 
class RegionCurrentResponseDto(
   @SerialName("currentRegionId")
   val currentRegionId: Int,
   @SerialName("fullRegionName")
   val fullRegionName: String) {
      fun toEntity() = RegionCurrentDataEntity(
              currentRegionId = currentRegionId,
              fullRegionName = fullRegionName
              )
      }
 )
```

## Parcelable

• 안드로이드 기반 인터페이스 (Android‑Specific Interface): Parcelable은 안드로이드 컴포넌트 내에서 고성능 프로세스 간 통신(IPC7)을 위해 특별히 설계된 안드로이드 특정 인터페이스입니다.
• 성능: Parcelable은 안드로이드에 최적화되어 있고 리플렉션에 의존하지 않기 때문에 Serializable보다 빠릅니다. 많은 임시 객체 생성을 피하여 가비지 컬렉션을 최소화합니다.
• 사용 사례: Parcelable은 성능이 중요한 안드로이드 데이터 전달, 특히 IPC나 Activity 또는 Service 간 데이터 전달에 선호됩니다.

이 설정을 사용하면 writeToParcel과 같은 메서드를 재정의하거나 CREATOR를 구현할 필요가 없어 보일러 플레이트 코드를 크게 줄이 고 가독성을 향상시킵니다.

[[Android] Serializable vs Parcelable](https://jinudmjournal.tistory.com/224)