# Q). 57 Jetpack Paging 라이브러리는 어떤 메커니즘으로 동작하나요?

> 대규모 데이터 셋을 청크 또는 “페이지” 단위로 로드하고 표시하는 프로세스를 돕도록 설계된 안드로이드 아키텍쳐 컴포넌트입니다. 데이터 베이스나 API 와 같은 소스에서 데이터를 효율적으로 가져와야 하는 애플리케이션에 특히 유용하며, 메모리 사용량을 최소화하고 RecyclerView 기반 UI의 전반적인 성능을 향상시킵니다.
> 

Paging 라이브러리는 데이터를 점진적으로 로드하기 위한 구조화된 접근 방식을 제공합니다. 데이터 캐싱, 재시도 메커니즘, 효율적인 메모리 사용과 같은 주요 측면을 기본적으로 처리합니다. 해당 라이브러리는 로컬데이터소스(가령, Room 데이터베이스)와 원격 소스(가령,네트워크 API) 또는 이 둘의 조합을 모두 지원합니다.

### Paging 라이브러리의 구성 요소

1. **PagingData:** 점진적으로 로드되는 데이터 스트림을 나타냅니다. RecyclerView와 같은 UI 컴포넌트에 의해 관찰되고 사용될 수 있습니다.
2. **PagingSource:** 데이터 소스에서 데이터가 로드되는 방식을 정의하는 역할을 합니다. 위치 또는 ID와 같은 키값을 기반으로 데이터 페이지를 로드하는 메서드를 제공합니다.
3. **Pager:** PagingSource와 PagingData 간의 중개자 역할을 합니다. PagingData 스트림의 생명주기를 관리합니다.
4. **RemoteMediator:** 로컬 캐싱과 원격 API 데이터를 결합할 때 경계 조건을 구현하는 데 사용됩니다.

![image.png](attachment:bb6c026b-0ce7-4897-8ee2-0adbe296707b:image.png)

### Paging 라이브러리 작동 방식

Paging 라이브러리는 데이터를 페이지로 분할하여 효율적인 데이터로딩을 가능하게 합니다. 사용자가 RecyclerView를 스크롤하면 라이브러리는 필요에 따라 새 데이터 페이지를 가져와 최소한의 메모리
사용량을 보장합니다. 이 라이브러리는Flow 또는 LiveData를 기본적으로 지원하여 데이터 변경 사항을 관찰하고 그에 따라 UI를 업데이트할 수 있도록 합니다

1. PagingSource를 정의하여 데이터 가져오는 방법을 지정합니다.
2. Pager를 사용하여 PagingData의 Flow를 생성합니다.
3. ViewModel에서 PagingData를 관찰하고 RecyclerView에서 렌더링하기 위해 PagingDataAdapter에 전달합니다.

대량 데이터를 “성능 좋고, 버그 없이, 적은 코드로” 무한스크롤하기 위해서

보통 Jetpack compose 에서는 LazyColumn 을 이용해서 화면에 무한 스크롤을 구현하고 있잖아요, 그래서 화면에 렌더링 될 것만을 표시해서 recylerview와 같은 최적화를 시키는 느낌인데

LazyColumn 에 해당하는 item을 서버에서 받아온다고 치면

“초기 화면에 크기에 따라 10개정도의 item을 나타낸다” 를 가정 했을때

1. 서버에서 100~1000개 정도되는 item을 한번에 요청해서 필요시에  스크롤을 통해 렌더링 하는 것 과
2. 필요할때마다 10개의 item을 load 하는거의 차이 를 알고싶어서

페이징 라이브러리는 **로컬** 데이터베이스 또는 **네트워크(Remote)**의 **데이터를 페이지 단위**로 UI에 쉽게 표현할 수 있도록 도와주는 라이브러리다.

라이브러리를 사용하지 않고 **기존**에 페이징을 구현하기 위해서는 RecyclerView와 같은 리스트 UI가 **상단 또는 하단에 도달했는지 판단하는 코드를 작성하고,** 다음 페이지를 로드(or Refresh)하는 코드를 **또 작성해야만 했다**.

페이징이 **필요한 모든 화면에 동일한 코드를 작성**해야만 했고 네트워크 오류, 스크롤 감지 이상(?)과 같은 **예외 처리 코드**도 상당했다.

위 문제점들을 포함한 여러 문제를 해결하기 위하여 Jetpack Paging Library가 출시되었다.

그리고 2021년 5월 **Paging 3** 라이브러리가 Stable 버전이 되었다.

### **Paging 2 vs Paging 3**

Paging 3 정식 출시로 Paging 2.x.x 기존 API 대부분을 지원 중단한 상태이다.

무엇이 달라졌는지 간단하게만 살펴보자.

- **Coroutine, Flow**, LiveData, RxJava를 위한 **최고 수준의 지원**을 제공한다.

- **재시도(Retry)와 새로고침(Refresh) 기능**을 포함하여 반응형 UI 디자인을 위해 **LoadState와 Error** Signal이 내장되었다.

- Paging 2의 DataSource 서브 클래스를 모두 통합하여 심플한 **데이터소스 인터페이스**를 제공한다.

- **취소** 기능이 내장되었다.

- **List Separator, Loading Header, Footer**가 내장되었다.

- 데이터 **캐싱**이 가능하다.

## Retrofit API

```kotlin
interface UserApi {
@GET("/users")
suspend fun getUsers(
@Query("page") page: Int,
@Query("size") size: Int
): UserResponse
}
```

```kotlin
data class UserResponse(
val users: List<User>,
val hasNext: Boolean 
)
```

```kotlin
data class User(
val id: Int,
val name: String
)
```

## PagingSource

```kotlin
class UserPagingSource(
private val api: UserApi
) : PagingSource<Int, User>() {
override fun getRefreshKey(state: PagingState<Int, User>): Int? {
    return state.anchorPosition?.let { pos ->
        val page = state.closestPageToPosition(pos)
        page?.prevKey?.plus(1) ?: page?.nextKey?.minus(1)
    }
}

override suspend fun load(params: LoadParams<Int>): LoadResult<Int, User> {
    return try {
        val page = params.key ?: 1
        val pageSize = params.loadSize

        val response = api.getUsers(page, pageSize)

        LoadResult.Page(
            data = response.users,
            prevKey = if (page == 1) null else page - 1,
            nextKey = if (response.users.isEmpty()) null else page + 1
        )
    } catch (e: Exception) {
        LoadResult.Error(e)
    }
}
}
```

## Repository

```kotlin
class UserRepository @Inject constructor(
private val api: UserApi
) {
fun getUsersPaging(): Flow<PagingData<User>> {
return Pager(
config = PagingConfig(
pageSize = 20,
enablePlaceholders = false
),
pagingSourceFactory = { UserPagingSource(api) }
).flow
}
}
```

## ViewModel

```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
repo: UserRepository
) : ViewModel() {
		val users = repo.getUsersPaging()
		    .cachedIn(viewModelScope)
		    
}
```

### UI

```kotlin
@Composable
fun UserListScreen(
viewModel: UserViewModel = hiltViewModel()
) {
val users = viewModel.users.collectAsLazyPagingItems()

LazyColumn {
    items(
        count = users.itemCount,
        key = { index -> users[index]?.id ?: index }
    ) { index ->
        val user = users[index]
        if (user != null) {
            Text(
                text = "${user.id} - ${user.name}",
                modifier = Modifier.padding(16.dp)
            )
        }
    }

    // 로딩/에러 UI
    users.apply {

        // 첫 로딩(refresh)
        when (loadState.refresh) {
            is LoadState.Loading -> {
                item { Text("초기 로딩중...") }
            }
            is LoadState.Error -> {
                item { Text("초기 로딩 실패") }
            }
        }

        // 추가 로딩(append)
        when (loadState.append) {
            is LoadState.Loading -> {
                item { Text("추가 로딩중...") }
            }
            is LoadState.Error -> {
                item { Text("추가 로딩 오류") }
            }
        }
    }
}

```

[[Android] Jetpack Paging 3 라이브러리 사용하기](https://genius-dev.tistory.com/entry/Android-Jetpack-Paging-3-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)

[페이징 라이브러리 개요  |  App architecture  |  Android Developers](https://developer.android.com/topic/libraries/architecture/paging/v3-overview?hl=ko#kts)

Jetpack Paging 라이브러리는 점진적 데이터 로딩 구현을 제공합니다. PagingSource, Pager, PagingDataAdapter를 포함한 핵심 구성 요소는 대규모 데이터 셋 처리를 돕습니다. 무한 스크롤, 페이지네이션된 API 또는 대규모 데이터베이스를 처리하는 애플리케이션에 특히 유용하며, 개발자가 데이터 쿼리 및 UI 업데이트를 업데이트하는 부분까지 라이브러리에 맡기고 그 외의 개발에 더 집중할 수 있도록 합니다.