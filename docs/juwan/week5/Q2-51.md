Q)51 VIewBinding 을 사용하면 어떤 장점이 있나요?

viewbinding 은 레이아웃의 뷰와 상호 작용하는 프로세스를 단순화 하기 위해 안드로이드에서 도입된 기능이다. 수동으로 findVieById() 를 호출하지 않아도 되고, 뷰에 접근하는 타입-세이프 방식을 제공하여 보일러 플레이트 코드를 줄이고 잠재적인 런타임 오류를 최소화합니다.

```kotlin
class MainActivity : AppCompatActivity() {}
// 바인딩 클래스 인스턴스 선언
private lateinit var binding: ActivityMainBinding
override fun onCreate(savedInstanceState: Bundle?) {
super.onCreate(savedInstanceState)
// 레이아웃 인플레이트 및 바인딩 클래스 초기화
binding = ActivityMainBinding.inflate(layoutInflater)
// 루트 뷰를 액티비티의 콘텐츠 뷰로 설정
setContentView(binding.root)
// 바인딩 객체를 통해 뷰에 직접 접근
binding.textView.text = "Hello, ViewBinding!"
binding.button.setOnClickListener { /* 클릭 리스너 로직 */ }
}
```

⇒ xml 할때 진짜 많이 쓰긴 했죠

## 기존 방식 (findViewById)

```kotlin
val textView = findViewById<TextView>(R.id.textView)
val button = findViewById<Button>(R.id.button)
```

## ViewBinding 방식

```kotlin
*// Activity*
private lateinit var binding: ActivityMainBinding

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = ActivityMainBinding.inflate(layoutInflater)
    setContentView(binding.root)
    
    binding.textView.text = "Hello"
    binding.button.setOnClickListener { }
}
```

- 타입 안전성 : 캐스팅할 필요 없이 뷰에 직접 접근하여 타입 불일치로 인한 런타임 오류를 제거한다.
- 깔끔띠 : findViewById()  를 호출할 필요가 없어지고 보일러 플레이트 코드가 줄어듭니다.
- null 안전성 : nullable 타입의 뷰를 자동으로 처리하여 선택적 UI 컴포넌트와 상호 작용할 때 더 안전한 코드를 보장합니다.
- 성능 : DataBinding 과 달리 ViewBinding은 바인딩 표현식이나 추가 XML 파싱을 사용하지 않으므로 런타임 오버헤드가 최솨 된다.

DataBinding은 바인딩 표현식 및 양방향 데이터 바인딩과 같은 더 많은 기능을 제공하지만 더 복잡하고 런타임 오버헤드를 유발합니다.
반면에 ViewBinding은 순수하게 뷰 상호 작용 단순화에 중점을 두며 성능 면에서 더 가볍습니다. LiveData나 Flow 등을 바인딩하여 데이터를 직접적으로 결합하는 등과 같은 기능이 필요하지 않은 경우 이상적입니다.

요약

ViewBinding은 안드로이드 앱에서 뷰와 상호 작용하는 가볍고 타입 세이프한 방법으로, 보일러 플레이트 코드를 줄이고 코드 안전성을 향상시킵니다. findViewById()의 간단한 대안이며 DataBinding의 고급 기능이 필요하지 않은 경우 훌륭한 선택입니다. ViewBinding을 활성화하면 더 나은 유지 관리성과 런타임 안전성을 보장하면서 UI 상호작용을 간소화할 수 있습니다.