# Q) 8. Fragment 생명주기를 설명해주세요

각 Fragment 인스턴스는 연결된 부모 Activity의 생명주기와 별도로
자체적인 생명주기를 갖습니다. 사용자가 앱과 상호 작용함에 따라
Fragment는 추가되거나, 제거되거나, 화면 안팎으로 이동될 때와 같이
다양한 생명주기 상태를 갖습니다. 생명주기 단계에는 생성되고, 시작
되고, 화면에 나타나게 되고, 활성 상태가 되거나, 더 이상 필요하지
않을 때 중지되거나 소멸되는 상태로 전환되는 것 등이 포함됩니다.
이러한 생명주기를 올바르게 이해함으로써 Fragment가 리소스를 효과
적으로 처리하고, UI 일관성을 유지하며, 사용자와의 상호작용에서
원활하게 응답할 수 있습니다.
안드로이드의 Fragment 생명주기는 Activity 생명주기와 많이 유사하지만
Fragment만의 고유한 콜백 메서드가 존재합니다

![/assets/fragment_lifecycle.png](assets/fragment_lifecycle.png)

1. onAttach(): Fragment가 부모 Activity와 연결될 때 호출되는 첫 번째 콜백입니다. 이제 Fragment가 연결되었으며 Activity 컨텍스트와 상호 작용할 수 있습니다.
2. onCreate(): Fragment를 초기화하기 위해 호출됩니다. 이 시점에서 Fragment는 생성되었지만 UI는 아직 생성되지 않았습니다. 일반적으로 필수 컴포넌트를 초기화하거나 저장된 상태를 복원하는
곳입니다
3. onCreateView(): Fragment의 UI가 처음으로 그려질 때 호출됩니다. 이 메서드에서 Fragment 레이아웃의 루트 뷰를 반환합니다. LayoutInflater를 사용하여 Fragment의 레이아웃을 인플레이션하는
곳입니다.
4. onViewStateRestored(): Fragment의 뷰 계층이 생성되고 저장된 상태가 뷰에 복원된 후 호출됩니다.
5. onViewCreated(): 이 메서드는 Fragment의 뷰가 생성된 후 호출됩니다. 종종 UI 컴포넌트와 사용자 상호 작용 처리에 필요한 로직을 설정하는 데 사용됩니다.
6. onStart(): Fragment가 사용자에게 보이게 됩니다. 이는 Activity의 onStart() 콜백과 동일하며, Fragment가 이제 활성 상태이지만 아직 포그라운드에 있지는 않습니다.
7. onResume(): Fragment가 이제 완전히 활성 상태이며 포그라운드에서 실행 중이므로 사용자와 상호 작용이 가능합니다. 이 메서드는 Fragment의 UI가 완전히 화면에 표시되고 사용자가 상호 작용할 수
있을 때 호출됩니다.
8. onPause(): Fragment가 더 이상 포그라운드에 있지 않지만 여전히 화면에 보이는 경우 호출됩니다. Fragment가 포커스를 잃기 직전이며, Fragment가 포그라운드에 없을 때 지속해서는 안 되는 작업을
일시 중지해야 합니다.
9. onStop(): Fragment가 더 이상 보이지 않습니다. Fragment가 화면 밖에 있는 동안 지속해야할 필요가 없는 작업을 중지하는 곳입니다.
10. onSaveInstanceState(): Fragment가 소멸되기 전에 UI 관련 상태 데이터를 저장하여 나중에 복원할 수 있도록 호출됩니다.
11. onDestroyView(): Fragment의 뷰 계층이 제거될 때 호출됩니다. 메모리 누수를 방지하기 위해 어댑터를 지우거나 참조를 null로 만드는 등 뷰와 관련된 리소스를 정리해야 합니다.
12. onDestroy(): Fragment 자체가 소멸될 때 호출됩니다. 이 시점에서 모든 리소스를 정리해야 하지만 Fragment는 여전히 부모 Activity에 연결되어 있습니다.
13. onDetach(): Fragment가 부모 Activity에서 분리되어 더 이상 연결되지 않습니다. 이것이 마지막 콜백이며 Fragment의 생명주기가 완료됩니다

**fragmentManager**
fragmentManager는 FragmentActivity 또는 Fragment와 연결되어 있으며 Activity 수준에서 Fragment를 관리하는 역할을 합니다. 여기에는 부모 Activity에 직접 연결된 Fragment를 추가하거나 교체 또는 제거하는 동작이 포함됩니다.
Activity에서 supportFragmentManager를 호출하면 FragmentActivity에서 관리하 fragmentManager에 접근할 수 있습니다. fragmentManager에 의해 관리되는 Fragment는 구조적으로 형제 관계이며 동일한 계층 수준에서 작동합니다

**childFragmentManager**
childFragmentManager는 하나의 Fragment에 속하며 해당 Fragment의 자식 Fragment를 관리합니다. 이를 통해 Fragment가 다른 Fragment를 호스팅하여 중첩된 Fragment 구조를 만들 수 있습니다.
childFragmentManager를 사용하면 부모 Fragment의 생명주기 내에서 Fragment를 정의합니다. 이는 Fragment가 Activity의 Fragment 생명주기와 독립적이며, Fragment를 중첩해서 사용해야 하는 경우 Fragment 내에서 UI와 로직을 캡슐화하는 데 유용합니다

주요 차이점

1. 범위(Scope)
• fragmentManager는 Activity 수준에서 작동하며 Activity에 직접 연결된 Fragment를 관리합니다.
• childFragmentManager는 Fragment 내에서 작동하며 부모 Fragment 내에 중첩된 Fragment를 관리합니다.
2. 사용 사례(Use Case)
• Activity의 주요 UI 컴포넌트를 형성하는 Fragment에는 fragmentManager를 사용합니다.
• Fragment가 자체적으로 중첩 Fragment를 관리해야 할 때 childFragmentManager를 사용하여 더 모듈화되고 재사용 가능한 UI 컴포넌트를 만들 수 있습니다
3. 생명주기(Lifecycle)
• fragmentManager에 의해 관리되는 Fragment는 Activity의 생명주기를 따릅니다.
• childFragmentManager에 의해 관리되는 Fragment는 부모 Fragment의 생명주기를 따릅니다


xml → compose 로 마이그레이션 할때, 혹은 view + compose 를 같이 사용하고있는 프로젝트는 어떻게 관리할까?

## 생명주기 관리 방식

### 1. **XML Activity/Fragment 안에 Compose 넣기**

가장 흔한 패턴으로, 기존 XML 화면에 일부분만 Compose로 교체한다.

```kotlin
*// XML 기반 Activity*
class MainActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        *// XML 레이아웃 내부의 ComposeView 찾기*
        val composeView = findViewById<ComposeView>(R.id.compose_view)
        
        composeView.setContent {
            MyComposableContent()
        }
    }
    
    override fun onResume() {
        super.onResume()
        *// Activity 생명주기는 일반적으로 동작*
    }
    
    override fun onPause() {
        super.onPause()
        *// Activity 생명주기는 일반적으로 동작*
    }
}
```

**XML 레이아웃 (activity_main.xml):**

xml

```kotlin
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">
    
    *<!-- 기존 XML View -->*
    <TextView
        android:id="@+id/title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="XML TextView" />
    
    *<!-- Compose를 넣을 컨테이너 -->*
    <androidx.compose.ui.platform.ComposeView
        android:id="@+id/compose_view"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />
    
    *<!-- 또 다른 XML View -->*
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="XML Button" />
</LinearLayout>
```

**Composable 부분:**

```kotlin
@Composable
fun MyComposableContent() {
    *// ComposeView가 Activity/Fragment에 붙어있으므로// 자동으로 생명주기를 따라감*
    val lifecycleOwner = LocalLifecycleOwner.current
    
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            when (event) {
                Lifecycle.Event.ON_RESUME -> {
                    Log.d("Compose", "Compose is resumed")
                }
                Lifecycle.Event.ON_PAUSE -> {
                    Log.d("Compose", "Compose is paused")
                }
                else -> {}
            }
        }
        
        lifecycleOwner.lifecycle.addObserver(observer)
        
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
    
    Column {
        Text("This is Compose content")
        Button(onClick = { */* ... */* }) {
            Text("Compose Button")
        }
    }
}
```

**생명주기 흐름:**

```kotlin
Activity.onCreate()
  → ComposeView 생성
  → Composable 진입 (Composition)
  
Activity.onResume()
  → Composable도 활성 상태
  
Activity.onPause()
  → Composable도 일시정지
  
Activity.onDestroy()
  → ComposeView 제거
  → Composable 제거 (onDispose 호출)
```

### 2. **Fragment에 Compose 넣기**

```kotlin
class MyFragment : Fragment() {
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        *// Fragment 전체를 Compose로 만들기*
        return ComposeView(requireContext()).apply {
            setContent {
                MyFragmentContent()
            }
        }
    }
    
    *// 또는 XML 레이아웃과 혼용*
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        view.findViewById<ComposeView>(R.id.compose_section).setContent {
            PartialComposableContent()
        }
    }
}

@Composable
fun MyFragmentContent() {
    *// Fragment의 생명주기를 자동으로 따라감*
    val lifecycleOwner = LocalLifecycleOwner.current
    
    LaunchedEffect(Unit) {
        *// Fragment가 생성될 때 실행*
        loadData()
    }
    
    DisposableEffect(Unit) {
        onDispose {
            *// Fragment가 파괴될 때 실행*
            cleanup()
        }
    }
    
    Text("Fragment with Compose")
}
```

### 3. **Compose 안에 XML View 넣기** (반대 경우)

```kotlin
@Composable
fun ComposeWithXmlView() {
    *// AndroidView를 사용해서 XML View를 Compose 안에 삽입*
    AndroidView(
        factory = { context ->
            *// XML View 생성*
            LayoutInflater.from(context)
                .inflate(R.layout.legacy_view, null, false)
        },
        modifier = Modifier.fillMaxWidth(),
        update = { view ->
            *// View가 업데이트될 때마다 호출됨*
            val textView = view.findViewById<TextView>(R.id.text)
            textView.text = "Updated from Compose"
        }
    )
}
```

**생명주기 관리:**

```kotlin
@Composable
fun ComposeWithXmlViewLifecycle() {
    val lifecycleOwner = LocalLifecycleOwner.current
    
    AndroidView(
        factory = { context ->
            val view = CustomXmlView(context)
            
            *// XML View에도 생명주기 연결*
            val observer = LifecycleEventObserver { _, event ->
                when (event) {
                    Lifecycle.Event.ON_RESUME -> view.onResume()
                    Lifecycle.Event.ON_PAUSE -> view.onPause()
                    else -> {}
                }
            }
            
            lifecycleOwner.lifecycle.addObserver(observer)
            view
        },
        update = { view ->
            *// 리컴포지션 시 업데이트*
        }
    )
    
    DisposableEffect(Unit) {
        onDispose {
            *// 정리 작업*
        }
    }
}
```

### 4. **ViewModel 공유하기**

XML과 Compose가 같은 ViewModel을 공유할 수 있다.

```kotlin
class SharedViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data
    
    private val _stateFlow = MutableStateFlow("")
    val stateFlow: StateFlow<String> = _stateFlow
    
    fun updateData(newData: String) {
        _data.value = newData *// XML Fragment에서 관찰*
        _stateFlow.value = newData *// Compose에서 관찰*
    }
}

*// XML Fragment*
class XmlFragment : Fragment() {
    private val viewModel: SharedViewModel by activityViewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        *// LiveData 관찰*
        viewModel.data.observe(viewLifecycleOwner) { data ->
            textView.text = data
        }
    }
}

*// Compose 부분*
@Composable
fun ComposeSection(viewModel: SharedViewModel = viewModel()) {
    *// StateFlow 관찰*
    val data by viewModel.stateFlow.collectAsState()
    
    Text(text = data)
    
    Button(onClick = {
        viewModel.updateData("Updated from Compose")
    }) {
        Text("Update")
    }
}
```

### 5. 복합화면

```kotlin
*// Activity*
class HybridActivity : AppCompatActivity() {
    private val viewModel: MyViewModel by viewModels()
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_hybrid)
        
        *// XML 부분*
        findViewById<TextView>(R.id.xml_title).text = "XML Section"
        
        findViewById<Button>(R.id.xml_button).setOnClickListener {
            viewModel.updateCounter()
        }
        
        *// Compose 부분*
        findViewById<ComposeView>(R.id.compose_section).setContent {
            MaterialTheme {
                ComposeSection(viewModel)
            }
        }
        
        *// ViewModel 관찰 (XML에서)*
        viewModel.counter.observe(this) { count ->
            findViewById<TextView>(R.id.counter_text).text = "Count: $count"
        }
    }
    
    override fun onResume() {
        super.onResume()
        *// XML View들 활성화// Compose도 자동으로 활성화됨*
    }
    
    override fun onPause() {
        super.onPause()
        *// XML View들 일시정지// Compose도 자동으로 일시정지됨*
    }
}

@Composable
fun ComposeSection(viewModel: MyViewModel) {
    val counter by viewModel.counter.observeAsState(0)
    val lifecycleOwner = LocalLifecycleOwner.current
    
    *// 생명주기 이벤트 처리*
    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event ->
            when (event) {
                Lifecycle.Event.ON_RESUME -> {
                    *// Compose 섹션이 활성화될 때*
                    Log.d("Compose", "Compose section resumed")
                }
                Lifecycle.Event.ON_PAUSE -> {
                    *// Compose 섹션이 일시정지될 때*
                    Log.d("Compose", "Compose section paused")
                }
                else -> {}
            }
        }
        
        lifecycleOwner.lifecycle.addObserver(observer)
        
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
    
    Column(modifier = Modifier.padding(16.dp)) {
        Text("Compose Section")
        Text("Counter: $counter")
        Button(onClick = { viewModel.updateCounter() }) {
            Text("Increment from Compose")
        }
    }
}

class MyViewModel : ViewModel() {
    private val _counter = MutableLiveData(0)
    val counter: LiveData<Int> = _counter
    
    fun updateCounter() {
        _counter.value = (_counter.value ?: 0) + 1
    }
}
```

## 핵심 포인트

1. **ComposeView는 부모의 생명주기를 따라감**: Activity/Fragment의 생명주기 이벤트가 자동으로 전달됨
2. **LocalLifecycleOwner로 접근 가능**: Compose 내부에서 생명주기 이벤트를 관찰할 수 있음
3. **ViewModel 공유 가능**: LiveData와 StateFlow를 함께 사용해서 XML과 Compose 양쪽에서 관찰
4. **AndroidView로 역방향도 가능**: Compose 안에 XML View를 삽입할 수 있음

[[MindSync] Jetpack Compose로 마이그레이션](https://velog.io/@qure/Jetpack-Compose%EB%A1%9C-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98)