## Q13 ) 안드로이드에서 메모리를 어떻게 효율적으로 관리하며, 메모리 누수를 어떻게 방지하는지 설명해라

# 안드로이드 메모리 관리와 Jetpack Compose 생명주기

안드로이드 개발에서 메모리 관리는 앱의 성능과 안정성을 좌우하는 핵심 요소입니다. 특히 Jetpack Compose를 사용하는 현대적인 안드로이드 개발에서는 전통적인 생명주기 관리 방식과는 다른 접근이 필요합니다. 이 글에서는 안드로이드의 메모리 관리 메커니즘부터 Compose에서의 안전한 상태 관리까지 단계별로 살펴보겠습니다.

## 안드로이드 메모리 관리의 기본 원리

안드로이드는 가비지 컬렉션(Garbage Collection) 메커니즘을 통해 사용되지 않는 메모리를 자동으로 회수합니다. 관리형 메모리 환경이기 때문에 개발자가 수동으로 메모리를 할당하고 해제할 필요가 없습니다. 시스템 메모리가 부족해지면 Low Memory Killer를 사용하여 포그라운드 애플리케이션의 원활한 작동을 우선시합니다.

### 메모리 누수의 주요 원인

메모리 누수는 애플리케이션이 더 이상 필요하지 않은 객체에 대한 참조를 유지하여 가비지 컬렉터가 메모리를 회수하지 못할 때 발생합니다. 일반적인 원인은 다음과 같습니다:

- 부적절한 생명주기 관리
- 정적 참조(Static Reference) 남용
- Context에 대한 장기 참조 유지
- 등록된 리스너나 콜백 미해제

### 메모리 누수 방지를 위한 8가지 전략

**1. 생명주기를 인지하는 컴포넌트 사용**

ViewModel, LiveData, 그리고 `collectAsStateWithLifecycle`과 함께 사용하는 Flow 같은 생명주기 인지 컴포넌트를 활용하면 관련 생명주기가 끝날 때 리소스가 적절하게 해제됩니다.

**2. Context에 대한 장기 참조 피하기**

Activity나 Fragment의 Context를 static 변수나 싱글톤에 저장하면 메모리 누수가 발생합니다. 필요한 경우 Application Context를 사용하세요.

**3. 리스너 및 콜백 등록 해제**

등록한 리스너나 콜백은 반드시 적절한 시점에 해제해야 합니다.

**4. WeakReference 활용**

중요하지 않은 객체는 WeakReference를 사용하여 가비지 컬렉터가 필요 시 회수할 수 있도록 합니다.

**5. 누수 감지 도구 사용**

Android Studio의 Profiler는 Memory 탭에서 메모리 누수를 감지하고 표시해줍니다. 시스템 메모리에 앱이 미치는 영향을 분석할 수 있지만, 추적이 쉽지 않을 수 있습니다.

**6. View에 대한 정적 참조 피하기**

View는 Context를 참조하므로 static으로 저장하면 메모리 누수가 발생합니다.

**7. 리소스 닫기**

InputStream, Cursor 등의 리소스는 사용 후 반드시 닫아야 합니다.

**8. Fragment와 Activity 현명하게 사용**

필요 이상으로 복잡한 구조는 피하고, Single Activity Architecture를 고려하세요.

[Consuming flows safely in Jetpack Compose](https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3)

## Jetpack Compose에서의 안전한 Flow 수집

Compose에서는 상태 관리를 위해 다양한 관찰 가능한 타입을 지원합니다. Flow를 State로 변환할 때 중요한 것이 바로 생명주기를 고려한 수집 방식입니다.

![/assets/flow.png](assets/flow.png)

### collectAsState()의 문제점

일반적으로 ViewModel의 StateFlow를 화면에 반영할 때 이렇게 작성합니다:

```kotlin
val uiState = viewModel.uiState.collectAsState()
```

하지만 이 방식은 **생명주기를 인식하지 못합니다**. 화면이 비활성화되어도 Flow 수집을 계속하기 때문에:

- ViewModel이 불필요하게 데이터를 계속 emit
- API 요청이나 비용이 계속 발생
- 메모리 누수나 비효율적인 상태 수집 발생

Activity나 Fragment가 `onStop()` 상태가 되어도 데이터 수집이 계속되는 것입니다.

### collectAsStateWithLifecycle()로 해결하기

`collectAsStateWithLifecycle()`은 LifecycleOwner의 상태를 자동으로 감지하여 안전하게 collect를 중단하고 재개합니다:

- 화면이 `STARTED` 이상일 때만 Flow를 수집
- `onStop()` 이후에는 자동으로 중단
- 화면으로 돌아오면 자동 재개

내부적으로 `repeatOnLifecycle()`을 사용합니다:

```kotlin
lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {
    flow.collect { value ->
        *// State 갱신*
    }
}
```

### 두 방식의 비교

| 항목 | collectAsState() | collectAsStateWithLifecycle() |
| --- | --- | --- |
| Lifecycle 인식 | 없음 | 있음 |
| 화면 비활성화 시 | 계속 collect | 자동중단 |
| 메모리 효율 | 비효율적 | 효율적 |
| 권장 여부 | 기본 사용 가능 | Jetpack 권장 |
|  |  |  |
|  |  |  |

## Single Activity Architecture(SAA)에서의 생명주기 이해

### SAA의 핵심 개념

Single Activity Architecture에서는 Activity가 단 하나만 존재하고, 그 안에서 여러 화면을 Composable 함수로 교체하며 보여줍니다.

| 전통 구조 | SAA 구조 |  |
| --- | --- | --- |
| Activity 여러 개 | ACtivity 1개 |  |
| 각 Activity가생명주기를 가짐 | Activity만 진짜 생명주기를 가짐 |  |
| Fragment/Activity 전환 | Compose 전환(Navigation Compose) |  |

진짜 Android 생명주기(LifecycleOwner)는 오직 MainActivity 하나뿐입니다.

### Composable의 생명주기

Composable은 전통적인 Lifecycle을 갖지 않습니다. `onCreate()`, `onStart()` 같은 콜백이 없죠. 대신 "Composition Lifecycle"을 사용합니다:

![/assets/compose.png](assets/compose.png)

이는 Compose Runtime이 내부적으로 자동 관리하므로 개발자가 직접 다룰 필요가 거의 없습니다.

## NavBackStackEntry: Navigation의 생명주기 핵심

### NavBackStackEntry란?

NavBackStackEntry는 Navigation 그래프의 각 Destination(화면)에 대한 "스택 항목"이자 LifecycleOwner입니다. Navigation 그래프에서 하나의 `composable()`이 호출될 때마다 그 화면에 대응하는 NavBackStackEntry 객체가 생성됩니다.

이 Entry가 화면의 생명주기, ViewModel 저장소, SavedStateHandle 등을 관리합니다.

### 실제 Navigation 스택 예시

다음과 같은 Navigation 그래프가 있다고 가정해봅시다:

```kotlin
NavHost(
    navController = navController,
    startDestination = "home"
) {
    composable("home") { HomeScreen() }
    composable("mypage") { MyPageScreen() }
    composable("mypage/detail") { MyPageDetailScreen() }
}
```

사용자가 Home → MyPage → MyPageDetail 순서로 이동하면:

![image.png](attachment:85ee6b4c-d440-47ee-8cd9-64b132bae463:image.png)

### NavBackStackEntry의 내부 구조

```kotlin
class NavBackStackEntry internal constructor(...) {
    val destination: NavDestination        *// 어떤 화면인지*
    val arguments: Bundle?                 *// Navigation 파라미터*
    val lifecycle: Lifecycle               *// 화면 생명주기*
    val viewModelStore: ViewModelStore     *// ViewModel 보관소*
    val savedStateHandle: SavedStateHandle *// 상태 저장소*
}
```

하나의 화면은 NavBackStackEntry를 통해:

- Lifecycle 관리
- ViewModel 관리
- 데이터 유지

를 모두 담당받습니다.

### collectAsStateWithLifecycle과 NavBackStackEntry의 관계

`collectAsStateWithLifecycle()`은 내부적으로 `LocalLifecycleOwner.current.lifecycle`을 참조하며, 이것이 바로 현재 Destination의 NavBackStackEntry.lifecycleOwner를 반환합니다.

Navigation 이동 시점에 Lifecycle.State가 STARTED → STOPPED로 바뀌면 `collectAsStateWithLifecycle()`이 Flow collect를 자동 중단합니다.

## ViewModel 스코프 관리 전략

### ViewModel과 NavBackStackEntry

Compose에서 ViewModel을 얻을 때:

kotlin

```kotlin
val viewModel = hiltViewModel<MyPageViewModel>()
```

이는 내부적으로 현재 NavBackStackEntry.viewModelStore에서 ViewModel을 가져옵니다. 즉, **ViewModel은 Activity가 아니라 현재 화면의 NavBackStackEntry에 연결**됩니다.

Navigation Destination이 pop되면 해당 Entry가 스택에서 제거되고, 연결된 ViewModel도 함께 사라집니다.

### 여러 화면에서 ViewModel 공유하기

MyPage 메인 화면과 세부 화면들이 같은 데이터를 공유해야 한다면 어떻게 할까요?

**시나리오 A: 공유 데이터가 많은 경우**

하나의 ViewModel을 공유합니다:

kotlin

```kotlin
val parentEntry = remember(navController) {
    navController.getBackStackEntry("mypage")
}
val sharedViewModel = hiltViewModel<MyPageViewModel>(parentEntry)
```

이렇게 하면 MyPage Entry의 ViewModelStore를 참조하여 동일한 ViewModel 인스턴스를 사용합니다.

**시나리오 B: 완전히 다른 데이터를 다루는 경우**

각각 별도의 ViewModel을 사용합니다:

```kotlin
MyPageMainViewModel      *// 프로필*
MyPagePostsViewModel     *// 게시글 목록*
MyPageLikesViewModel     *// 찜 목록*
MyPageSettingsViewModel  *// 설정*
```

이는 단일 책임 원칙(SRP)에 맞고, 화면 전환 시 ViewModel이 자연스럽게 정리됩니다.

### Lifecycle 상태 변화 과정

Navigation 이동 시점의 상태 변화:

```
이벤트Lifecycle 상태 변화최초 진입Home: CREATED → STARTEDMyPage로 이동Home: STARTED → STOPPED<br>MyPage: CREATED → STARTEDDetail로 이동MyPage: STARTED → STOPPED<br>Detail: CREATED → STARTED뒤로가기Detail: DESTROYED<br>MyPage: STOPPED → STARTED
```

이 상태 변화를 기반으로 `collectAsStateWithLifecycle()`이 collect를 중단하거나 재개합니다.

## 화면별 collectAsStateWithLifecycle 사용 가이드

각 화면에서 `collectAsStateWithLifecycle()`을 사용해야 하는 이유는 명확합니다:

1. **Composable은 UI 단위로 생명주기가 다름**: 각 NavBackStackEntry가 독립적인 생명주기를 가집니다
2. **Flow 수집의 자동 관리**: 화면이 비활성화되면 불필요한 데이터 수집을 자동으로 중단합니다
3. **메모리 효율성**: 백그라운드에서의 리소스 낭비를 방지합니다

따라서 **대부분의 경우 각 화면에서 필요한 Flow마다 collectAsStateWithLifecycle을 사용하는 것이 권장**됩니다.