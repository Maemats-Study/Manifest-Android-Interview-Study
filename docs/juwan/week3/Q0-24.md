# Q 24) 예외를 어떻게 추적하나요? 그러게요

안드로이드에서는 예외를 추적하는 것은 앱에서 발생하는 문제를 효과적으로 진단하고 해결하는 데 중요합니다. 안드로이드는 문제를 식별하고 디버깅하는 데 도움이 되는 여러 도구와 기숳을 제공합니다.

## Logcat 을 이용한 예외 로깅

Android studio 에서 사용 가능한 LogCat은 로그를 보고 예외를 추적하는 아주 기본적인 도구이다. 예외가 발생하면 시스템은 예외 유형, 메세지 및 예외가 발생한 코드 줄을 포함하여 자세한 스택 트레이스를 logcat 에 기록한다. E/AndroidrRuntime 과 같은 키워드를 사용하여 Logcat 로그를 필터링 하여 예외 처리에 집중할 수 있다.

## Try -catch 를 이용한 예외 처리

try - catch 블록을 사용하면 예외를 제어된 방식으로 처리하고 코드의 중요한 부분에서 앱 크래시를 방지할 수 있습니다.

```kotlin
try {
		val result = performRiskyOperation()
} catch (e : Exception) {
				Log.e("Error", "Exception occurred: ${e.message}", e)
}
```

⇒ 위의 예시에서는 예외가 Logcat 에 기록되어 추적 및 해결이 용이해집니다.

[Android 개발시 Timber을 적용한 이유](https://2taezeat.github.io/posts/2023/android-%EA%B0%9C%EB%B0%9C%EC%8B%9C-timber%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%9C-%EC%9D%B4%EC%9C%A0/)

[[Kotlin] runCatching이란? runCatching 사용법](https://onlyfor-me-blog.tistory.com/716)

## 전역 예외 핸들러 사용하기

Thread.setDefaultUncaughtExceptionHandler 를 사용하여 전역 예외 핸들러를 설정하면 앱 전체에서 처리되지 않은 예외를 포착하는 데 도움이 됩니다. 이는 중앙 집중식 오류 보고 또는 로깅에 특히 유욯합니다.

```kotlin
class MyApplication : Application () {
				override fun Oncreat() {
							super.onCreate()
							val defaultHandler = Thread.getDefaultUncaughtExceoptionHandler()
							Thread.setDefaultUncaughtExceptionHandler { thread, exception ->
										Log.e("GlobalHandler", "Uncaught exception in thread ${thread.name}:									&{exception.message}" , exceptio)
										
										// 예외 세부 정보 저장 또는 서드 파티 솔루션으로 전송(Crashlytics 등)
										//  FirebaseCrashlytics.getInstance().recordException(exception)
										// 기존 핸들러 호출 (선택 사항, 시스템 기본 크래시 동작 유지)
 defaultHandler?.uncaughtException(thread, exception)
```

⇒ 이 접근 방식은 애플리케이션 전체의 런타임 문제를 디버깅하고 모니터링하는 데 매우 효과적입니다. 또한 디버그 또는 QA 빌드에서만 전역 예외 핸들러를 구현할 수 있습니다. 이를 통해 QA 전문가가 효율적으로
예외를 추적하고 개발팀에 자세한 보고서를 전달하여 디버깅 및 문제 해결 프로세스를 간소화할 수 있습니다. 구현 사례에 대해 더 자세히 알아보고 싶다면 GitHub의 오픈 소스 프로젝트인 snitcher46를 확인해
볼 수 있습니다.

### 1. try- catch : 예상 가능한 예외 처리

```kotlin
fun login(email: String, password: String) {
    try {
        val result = authApi.login(email, password)
        *// 성공 처리*
    } catch (e: NetworkException) {
        Log.e("Login", "네트워크 오류", e)
        showToast("인터넷 연결을 확인해주세요")
    } catch (e: InvalidCredentialsException) {
        Log.e("Login", "로그인 실패", e)
        showToast("아이디 또는 비밀번호가 틀렸습니다")
    }
}
```

### 2. 전역 핸들러: 놓친 모든 예외

```kotlin
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        
        Thread.setDefaultUncaughtExceptionHandler { thread, exception ->
            *// try-catch로 안 잡은 모든 예외가 여기로!*
            Log.e("GlobalHandler", "크래시 발생!", exception)
            
            *// Crashlytics에 전송*
            FirebaseCrashlytics.getInstance().recordException(exception)
            
            *// 앱 크래시 정보를 파일로 저장 (디버그용)*
            saveErrorLog(exception)
        }
    }
}

```

```kotlin
// di/AppModule.kt
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
@Provides
@Singleton
fun provideGlobalExceptionHandler(
@ApplicationContext context: Context
): GlobalExceptionHandler {
return GlobalExceptionHandler(context, context)
}
}
```

```kotlin
// Application
@HiltAndroidApp
class PawKeyApplication : Application(), ImageLoaderFactory {
@Inject
@Named("kakao.native.key")

@Inject
lateinit var globalExceptionHandler: GlobalExceptionHandler

override fun onCreate() {
    super.onCreate()

    setTimber()
    setDarkMode()
    globalExceptionHandler.install()

    KakaoMapSdk.init(this, kakaoNativeKey)
    NaverMapSdk.getInstance(this).client =
        NaverMapSdk.NcpKeyClient(BuildConfig.NAVERMAP_CLIENT_ID)
}

private fun setTimber() {
    if (BuildConfig.DEBUG) Timber.plant(Timber.DebugTree())
}

private fun setDarkMode() {
    AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)
}

override fun newImageLoader(): ImageLoader {
    return ImageLoader.Builder(this)
        .memoryCache {
            MemoryCache.Builder(this)
                .maxSizePercent(0.25)
                .build()
        }
        .diskCache {
            DiskCache.Builder()
                .directory(cacheDir.resolve("image_cache"))
                .maxSizeBytes(50 * 1024 * 1024)
                .build()
        }
        .logger(DebugLogger())
        .respectCacheHeaders(false)
        .build()
}

lateinit var kakaoNativeKey: String
```

## Firebase Crashlytics 사용하기

Firebase Crashlytics47는 프로덕션 환경에서 예외를 추적하는 훌륭한 도구입니다. 처리되지 않은 예외를 자동으로 기록하고 스택 트레이스, 기기 상태 및사용자 정보와 함께 자세한 크래시 보고서를 제공합니다.
중요하지 않은 문제에 대해 커스텀 예외를 기록할 수도 있습니다.

> 스택 트레이스 = "오류가 발생하기까지의 함수 호출 경로”
> 

```kotlin
try {
val data = fetchData()
 } catch (e: IOException) {
				 FirebaseCrashlytics.getInstance().recordException(e)
 }
```

⇒ Crashlytics는 Firebase와 통합되어 크래시 분석 및 해결 추적을 용이하게 합니다

프로덕션 환경에서는 Thread.setDefaultUncaughtExceptionHandler를 직접 구현하는 대신, Firebase Crashlytics와 같은 전문적인 충돌 보고 도구를 사용하는 것이 가장 효과적입니다. Crashlytics는 자동으로 모든 포착되지 않은 예외를 수집하여 Firebase 콘솔에서 분석할 수 있도록 해줍니다.

**구현 단계:**

1. **Firebase 프로젝트 설정 및 Crashlytics SDK 추가:**
    - build.gradle 파일에 Crashlytics 종속성을 추가합니다.
2. **테스트 충돌 강제 발생:**
    - 초기 설정 후, 테스트를 위해 일부러 충돌을 발생시켜 보고가 제대로 올라오는지 확인할 수 있습니다.
3. **Compose 앱에서 사용:**
    - Crashlytics는 Thread.UncaughtExceptionHandler를 내부적으로 구현하므로, 별도의 추가 코드 없이도 Compose에서 발생하는 대부분의 충돌을 자동으로 잡아냅니다.

**결론 및 권장사항**

- **개발 단계:** Thread.setDefaultUncaughtExceptionHandler를 사용하여 디버깅 정보를 로그로 출력하거나, CoroutineExceptionHandler를 활용하여 코루틴 예외를 처리하는 것이 유용합니다.
- **운영 단계:** 앱의 안정성을 높이고 사용자 경험을 개선하려면 **Firebase Crashlytics**와 같은 전문적인 도구를 사용하는 것이 가장 좋습니다. Crashlytics는 예외를 자동으로 보고하고 분석 기능을 제공하여 문제의 우선순위를 정하고 해결하는 데 도움을 줍니다.

[[Android] Firebase - Analytics 및 Crashlytics를 활용해 앱 사용자에 대한 데이터를 수집해보자.](https://velog.io/@cksgodl/Android-Firebase-Analytics-%EB%B0%8F-Crashlytics%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%B4-%EC%95%B1-%EC%82%AC%EC%9A%A9%EC%9E%90%EC%97%90-%EB%8C%80%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%88%98%EC%A7%91%ED%95%B4%EB%B3%B4%EC%9E%90)

## **브레이크포인트(Breakpoints)를 이용한 디버깅**

Android Studio에서 브레이크포인트를 찍으면 코드 실행을 일시 중지하고 앱 상태를 점진적으로 검사할 수 있습니다. 이는 개발 중에 예외의 원인을 식별하는 데 특히 유용합니다. 디버그 모드를 활성화 하고 브레이크포인트에 도달했을 때 변수, 메서드 호출 및 예외 스택 트레이스를 상세하게 탐색할 수 있습니다

## 버그 리포트(Bug Report) 캡처하기

안드로이드에서 버그 리포트를 캡처하면 기기 로그, 스택 트레이스 및 시스템 정보를 수집하여 문제를 진단하고 수정하는 데 도움이 됩니다. 기본적으로 ADB는 서드파티 솔루션 없이 버그 리포트를 캡처하고 생성
하는 훌륭한 방법을 제공합니다. 세 단계로 버그 리포트를 생성할 수 있습니다.

1. 개발자 옵션: 개발자 옵션을 활성화하고, 설정 > 개발자 옵션 > 버그 신고로 이동하여 버그신고유형을선택하고생성된보고서를 공유합니다.
2. Android Emulato에서 버그 신고 캡처: 확장 컨트롤을 열고 버그 신고를 선택한 다음 관련 세부 정보와 함께 보고서를 저장합니다.
3. ADB (Android Debug Bridge)를 사용하여 버그 신고 캡처: 터미널에서 adb bugreport /path/to/save/bugreport를 실행하거나, adb‑s <device_serial_number> bugreport로 특정 기기를 지정합니다.