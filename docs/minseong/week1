# Q.0) 안드로이드란 무엇인가요?

안드로이드란 스마트폰과 태블릿과 같은 모바일 기기를 위해 주로 설계된 오픈소스 운영 체제. 구글에 의해 개발 및 유지 관리되며 리눅스 커널 기반

1. 오픈 소스 및 커스텀화
2. sdk를 이용한 애플리케이션 개발
3. 풍부한 앱 생태계
4. 멀티태스킹 및 리소스관리 - 가비지 컬렉션
5. 다양한 하드웨어 지원 - 광범위한 기기 구동, 호환성 제공

## 아키텍처

플랫폼 아키텍처는 모듈식 계층화되어 있음, 여러 구성 요소로 이뤄짐

하위부터 정리 아래에서 위로 올라가는 바텀업

- 리눅스 커널
    - 운영체제의 기반, 하드웨어 추상화를 처리하여 소프트웨어와 하드웨어 간의 원활한 상호 작용 보장 / 주요 책임에는 메모리 및 프로세스 관리, 보안 강화, wifi, bluetooth, 디스플레이 같은 하드웨어 구성요소 드라이버 관리
- 하드웨어 추상화 **HAL**
    - 안드로이드의 java api 프레임워크를 기기 하드웨어에 연결하는 표준 인터페이스 제공, 각 라이브러리 모듈로 구성되고 카메라나 블루투스 같은 하드웨어 구성 요소에 맞춰짐, 프레임워크 api가 하드웨어 접근 시 hal 모듈을 동적으로 로드
- 안드로이드 런타임 및 코어 라이브러리 - ART,Core libraries
    - ART는 코틀린 또는 자바에서 컴파일된 바이트 코드를 사용하여 어플 실행, 최적화된 성능을 위해 AOT 및 JIT 컴파일을 지원, core는 데이터 구조, 파일 조작, 스레딩 등을 위한 필수 api 제공하여 앱 개발에 포괄 환경 제공
- 네이티브 c, c++ 라이브러리
    - opengl과 같은 라이브러리 그래픽 렌더링 관리, sqlite 데베 작업, webkit 웹 콘첸츠 표시 용이, 이러한 라이브러리는 프레임워크와 어플 성능 집약적 작업을 위해 직접 사용, cmake ⇒ C/C++ 라이브러리를 빌드하는 다양한 명령어들을 포함
- 안드로이드 프레임워크
    - 앱 개발을 위한 고수준 서비스와 api 제공, activitymanager, notificationmanager, contentprovider 등
- 애플리케이션
    - 최상위 계층에는 안드로이드 sdk를 사용해 생성된 서드파티앱을 포함한 모든 유저 기반 앱, 사용자에게 다양한기능+원할운용을 위한 하위 계층과 통신

## 실전 질문

Q) 안드로이드 플랫폼 아키텍처는 Linux Kernel, Android Runtime
(ART), Hardware Abstraction Layer (HAL) 등 여러 계층으로 구성
됩니다. 이 구성 요소들이 애플리케이션 실행과 하드웨어와의 상호
작용을 위해 어떻게 작동하는지 설명해 주세요.

**ART**는 자바 , 코틀린으로 작성한 앱 코드를 번역하고 실행 - 홀 관리 → 사진찍으래요

**HAL** 은 상위 계층 프레임워크와 하위 계층 리눅스 커널 간의 번역기로 표준 인터페이스를 제공 - 주방장 → 오케이 손님이 사진 찍으랜다

**리눅스 커널**은 전문 요리사로 하드웨어와 직접적으로 소통하는 유일한 부분, 드라이버 관리로 직접 작동 - 요리사 또는 설비 → 예 쉐프 사진찍겠습니다

# Q.1) 인텐트란?

수행될 작업에 대한 추상적인 설명, 메시징 객체 역할, 서비스 브로드캐스트 액티비티 시작 시 사용

명시적 및 암시적 두 intent가 존재 / **사실 명시적을 권장함** 암시적은 내용이 공개적이고 그 인텐트 필터 정의하면 어느 어플이나 수신 가능해서 공격에 이용가능

- 명시적
    - 호출한 컴포넌트 - 액, 서 를 지정하고 명시하고 시작
- 암시적
    - Intent.~ 로 어떤 컴포넌트가 intent를 처리하는 지 알 수 있음 , 특정 컴포넌트 지정은 x / 시스템이 intent를 처리할 앱을 결정 → 예를 들어 text/plain과 같은 action

## 실전 질문

Q) 명시적 인텐트와 암시적 인텐트의 차이점은 무엇이며, 각각 어떤
시나리오에서 사용해야 하나요?

→ 명시적은 명확한 컴포넌트를 intent가 명시 ⇒ 액,서,브로 메시징 객체 역할 또는 화면 이동 시

→ 암시적은 대상을 직접 지정은 하지 않고 외부 앱이나 다른 컴포넌트가 유연하게 사용 → 액션으로 메일앱 / text/plain같이 부를때나 action_view로 웹페이지 이동 시

Q) 안드로이드 시스템은 암시적 인텐트를 처리할 앱을 어떻게 결정하
며, 적합한 애플리케이션을 찾지 못하면 어떻게 되나요?

→ 우선 패키지 매니저를 통해 intent-filter 기준으로 검색하여 처리, 근데 없으면 

ActivityNotFoundException 발생 따라서 `queryIntentActivities()` 메서드를 사용하여 해당 인텐트를 처리할 수 있는 컴포넌트 목록을 가져온 후 이 목록이 비어있지 않을 때만 `startActivity()`를 호출하면 됨

# Q.2) pending intent의 목적

다른 애플리케이션이나 시스템 컴포넌트가 애플리케이션을 대신하여 미리 정의된 intent를 나중에 실행할 수 있는 권한 부여하는 intent, 앱의 수명 주기를 벗어나 트기거 되어야할 때 유용 - intent의 wrapper 역할, 

악의적인 앱이 기본 Intent를 수정하는 것을 방지하기 위해
PendingIntent에는 항상 FLAG_IMMUTABLE을 설정

플래그

- FLAG_UPDATE_CURRENT: 기존 PendingIntent를 새 데이터로 업데이트합
니다.
- FLAG_CANCEL_CURRENT: 새 PendingIntent를 만들기 전에 기존
PendingIntent를 취소합니다.
- FLAG_IMMUTABLE: PendingIntent를 변경 불가능하게 만들어 수신자가
수정하는 것을 방지합니다. (Android 12+ 에서 중요)
- FLAG_ONE_SHOT: PendingIntent가 한 번만 사용될 수 있도록 보장

## 실전 질문

Q) PendingIntent란 무엇이며 일반 Intent와 어떻게 다른가요?
PendingIntent 사용이 필요한 시나리오를 제시해 줄 수 있나요?

→ 앱의 생명주기를 따르지 않음, 플래그가 존재하며 이 플래그로 동작 방식과 시스템 또는 다른 컴포넌트와의 상호 작용 방식을 제어

시나리오 - 알람 ,  알람 수신하여 띄우고 알람 클릭 시 해당 activity 또는 동작

# Q.3) Serializable과 Parcelable의 차이점은
무엇인가요

모두 다른 컴포넌트 간에 데이터 전달 시 사용되는 메커니즘

- serializable
    - java 표준 인터페이스 - 바이트 스트림 변환하여 전달 또는 디스크 쓰기
    - 리플렉션 기반 - 시스템이 런타임에 클래스와 필드 동적 검사하여 객체 직렬화
    - 성능 - 느림, 메모리 오버헤드 증가
    - 안드로이드 특정 코드가 아닌 코드베이스 다룰 때 유용
- parcelable
    - 안드로이드 기반 인터페이스 - 컴포넌트 내에서 고성능 프로세스간 통신을 위함
    - 성능 - 안드로이드 최적화 , 빠름, 가비지 컬렉션 최소화
    - 안드로이드 데이터 전달, activity, service간
    - **주의 : 무작정은 안되고 원시타입만 가능 - 만약 아닌데 사용 시 exception 그러면 rawvalue 써야함**

## 실전 질문

Q) 안드로이드에서 Serializable과 Parcelable의 차이점은 무엇이며,
일반적으로 컴포넌트 간 데이터 전달에 Parcelable이 선호되는 이유는
무엇인가요

→ serializable은 리플렉션 기반이라 느림, 그리고 직렬화 중 많은 임시 객체 생성으로 메모리 오버헤드 증가 parcelable은 안드로이드 기반 인터페이스로 고성능 프로세스간 통신을 위해 만들어져서 빠르고 안드로이드 최적화라 더더욱 컴포넌트간 데이터 전달에 선호됨 대신 원시타입이 아닐 때 사용 시 오류가 발생할 수 있음으로 직접 직렬화 시 rawValue를 사용하도록 하자

**TIP parcel과 parcelable**

`Parcel`은 데이터를 담는 컨테이너이고 `Parcelable`은 그 컨테이너에 담길 수 있는 객체임을 명시하는 규칙임

parcel은 택배 상자 parcelable은 택배 가능 스티커 붙은 물건으로 스티커 붙은 물건만 parcel에 담을 수 이씀 근데 parcel은 거의 안씀 시스템이 내부적으로 사용함

# Q.4) Context란 무엇이며 어떤 유형의 Context가 있나요?

context는 애플리케이션 환경, 상태, 리소스클래스 접근 제공

어마 무시한 역할을 함

- application context
    - 앱 라이프 사이클에 연결됨, 액티비티나 프래그먼트에는 독립
    - 전체 앱 생명주기에 지속되야하는 브로드 캐스트 리시버 등록, 데이터 베이스와 같은 sharedpreference 등에 접근 시
- activity context
    - activity 생명주기, 리소스 접근 시작 inflation에 사용
    - ui 컴포넌트 생성 또는 업데이트
    - 다른 액티비티 실행 시
    - 리소스 테마 접근 시
- service context
    - service 생명주기, 네트워크 작업, 백그라운드 실행작업
- broadcast context
    - 수명 짧, 특정 브로드 캐스트 응답용, 그래서 장기적인 태스크 수행에 사용x

결국 

1. 리소스접근
2. 레이아웃 인플레이션
3. 액티비티 및 서비스 시작
4. 시스템 서비스 접근
5. 데이터 베이스 및 sharedpreference 접근 에 주로 사용

## 실전 질문

Q) 안드로이드 애플리케이션에서 올바른 유형의 Context를 사용하는
것이 왜 중요하며, Activity Context에 대해 오랜 참조를 유지하는
것은 잠재적으로 어떤 문제를 발생시킬 수 있나요?

메모리 누수 - 액티비티 context 이면서 전역에서 사용하는 방식 등

리소스용으로 사용하는데 application context 같이 ui 리소스 정보가 없는 것을 사용하면 크래시 / context는 백그라운드 스레드에서 사용피하기 context는 메인 스레드용

**TIP contextwrapper**

context의 특정 동작 개선 및 재정의 시 사용, 호출 중개, 추가 기능, 커스텀 동작을 제공하는 목적으로 많이 사용

ContextWrapper는 안드로이드에서 Context 동작을 커스텀하기 위한 유연
하고, 재사용 가능한 API입니다. 개발자가 원본 Context를 직접 변경
하지 않고 호출을 위임하여 Context의 동작을 재정의 할 수 있게 하고,
적응 가능한 애플리케이션을 개발하는데 데 유용합니다

**TIP2 this와 basecontext 차이**

Activity에서 this는 현재 Activity 인스턴스를 참조하며 생명주기 및 UI
특정 기능을 갖춘 고수준 Context를 제공합니다. 반면에 baseContext는
Activity가 기반으로 하는 원초적인 Context를 나타내며, 종종 커스텀
ContextWrapper 구현과 같은 고급 시나리오에서 사용됩니다. 통상적인 안드로이드 개발에서는 this가 가장 보편적으로 사용되지만, baseContext를 이해하면 디버깅이나 이식 가능한 & 재사용 가능한 컴포넌트 생성에 사용할 수 있습니다

# Q.5) **Application 클래스란 무엇인가요?**

**Application 클래스**는 안드로이드 애플리케이션의 **전역 상태와 생명주기를 유지**하는 역할을 합니다. 이 클래스는 Activity, Service, BroadcastReceiver와 같은 다른 컴포넌트보다 **가장 먼저 초기화**되는 앱 프로세스의 진입점 역할을 수행하며, 앱 전역에 걸쳐 공유되는 리소스 및 인스턴스를 초기화하는 데 이상적

- **주요 역할:** 앱의 전체 생명주기 동안 사용 가능한 **Context를 제공**합니다.
- **생명주기 메서드:** 시스템이 메모리 부족 상태를 감지할 때 트리거되는 `onLowMemory()` 및 `onTrimMemory()`와 같은 메서드들을 포함합니다.
- **사용 방법:** 커스텀 Application 클래스를 만들려면 `Application` 클래스를 상속받고 `AndroidManifest.xml` 파일의 `<application>` 태그에 지정해야 합니다.

## 실전 질문

Q) Application 클래스의 목적은 무엇이고, 생명주기 및 리소스 관리 측면에서 Activity와는 어떻게 다른가요?

→ Application 클래스는 **전역 애플리케이션 상태와 생명주기를 유지**하는 역할

activity에 비해 가장 오래 지속되며 리소스는 전역 의존성을 초기화하는데 사용되는 반면 액티비티는 뷰 관련 리소스 및 데이터만 관리

# **Q.6) AndroidManifest 파일의 목적은 무엇인가요?**

`AndroidManifest.xml` 파일은 안드로이드 프로젝트에서 **가장 중요한 구성 파일**로, 안드로이드 운영 체제에 애플리케이션에 대한 필수 정보를 정의합니다. 이 파일은 애플리케이션의 **컴포넌트, 권한, 하드웨어 및 소프트웨어 기능 등을 정의**하여 애플리케이션과 OS 간의 브릿지 역할을 수행합니다.

# Q.7) **Activity 생명주기를 설명해주세요**

oncreate → onstart(onrestart) → onresumed → onpause → onstop → ondestroy

![image.png](attachment:743e6cb8-27bc-40bb-9362-225fed7609fe:image.png)

백그라운드에 있을 때 ui를 업데이트 하려고하면 크래시 발생

ui는 애플리케이션이 백그라운드에 이씅ㄹ 때 수집을 중단해야한다

**collectasstatewithlifecycle의 주요한 점**

## 실전 질문

Q) onPause()와 onStop()의 차이점은 무엇인지 설명하고, 리소스 점
유율이 높은 작업을 처리하는 경우 해당 메서드들을 어떤 시나리오에서
사용해야 하나요

→ onpause는 activity가 다이얼로그 등에 의해 잠시 뷰가 가려질 때 호출, 포커스가 아닌 상태, onstop은 더 이상 사용자에게 보이지 않을때, activity가 중지되지는 않았으니 그 안에 무거운 작업 들의 리소스를 해제해야함, 

onstop이나 ondestroy에서

TIP 

lifecycle 속성은 ComponentActivity의 하위 클래스에서 노출하는
Lifecycle 클래스의 인스턴스

# Q.8)  Fragment 생명주기를 설명해주세요

각 Fragment 인스턴스는 연결된 부모 Activity의 생명주기와 별도로
자체적인 생명주기

onattach → oncreate → oncreateview → onviewstaterestored → onviewcreated → onstart → onresume → onpause → onstop → onsaveinstancestate → ondestroyview → ondestroy

TIP

fragmentManager
fragmentManager는 FragmentActivity 또는 Fragment와 연결되어 있으며
Activity 수준에서 Fragment를 관리하는 역할을 합니다. 여기에는 부모
Activity에 직접 연결된 Fragment를 추가하거나 교체 또는 제거하는
동작이 포함

childFragmentManager
childFragmentManager는 하나의 Fragment에 속하며 해당 Fragment의 자식
Fragment를 관리합니다. 이를 통해 Fragment가 다른 Fragment를 호스팅
하여 중첩된 Fragment 구조를 만들 수 있습니다.
childFragmentManager를 사용하면 부모 Fragment의 생명주기 내에서
Fragment를 정의합니다. 이는 Fragment가 Activity의 Fragment 생명주
기와 독립적이며, Fragment를 중첩해서 사용해야 하는 경우 Fragment
내에서 UI와 로직을 캡슐화하는 데 유용

## 실전 질문

Q) onCreateView()와 onDestroyView()의 목적은 무엇이며, 해당 메
서드에서 뷰 관련 리소스를 올바르게 처리하는 것이 왜 중요한가요?

→ onCreateView는 프래그먼트가 화면에 표시될 뷰 계층 구조를 생성하여 반환함

onDestroyView은 onCreateView에서 만든 모든 리소스 해제

뒤로 가기 시 뷰는 파괴되지만 인스턴스 자체는 메모리에 남아있기 때문에 뷰 참조를 null하지않으면 메모리 누수로 이어짐

# Q.9) **Service란 무엇인가요?**

**Service**는 앱이 사용자 상호 작용과 **독립적으로 장기적으로 작업을 수행**할 수 있도록 하는 백그라운드 컴포넌트입니다. Activity와 달리 사용자 인터페이스가 없으며, 앱이 포그라운드에 있지 않을 때도 계속 실행될 수 있습니다. 일반적으로 파일 다운로드, 음악 재생, 데이터 동기화와 같은 백그라운드 작업에 사용

## 실전 질문

Q) 안드로이드에서 Started 서비스와 Bound 서비스의 차이점은 무엇이며, 각각 언제 사용해야 하나요?

→ Started Service 는 자신만의 생명주기에 백그라운드에서 작업을 독립적으로 수행, bound는 클라이언트 서버와 같은 관계처럼 클라이언트에 종속적이고 양방향, 서비스에 연결된 컴포넌트가 하나라도 잇는 동안 실행

# Q.10) **BroadcastReceiver란 무엇인가요?**

**BroadcastReceiver**는 앱이 안드로이드 운영 체제 전체의 브로드캐스트 메시지나 앱 특정 브로드캐스트를 **수신하고 응답**할 수 있도록 하는 컴포넌트입니다. 이는 시스템이나 다른 애플리케이션에 의해 트리거될 수 있으며, 네트워크 연결 변경, 배터리 상태 업데이트와 같은 다양한 이벤트를 알리는 데 사용됩니다.

- **역할:** 동적인 시스템 또는 앱 수준 이벤트에 반응하는 응답성 있는 애플리케이션을 구축하는 데 유용한 메커니즘

## 실전 질문

Q) 브로드캐스트의 유형에는 어떤 것이 있으며, 기능 및 사용 측면에서
시스템 브로드캐스트와 커스텀 브로드캐스트는 어떤 차이가 있나요?

→ 시스템과, 커스텀이 있다 / 

시스템

- 안드로이드 os가 송신 주체이며 시스템 상태 변경을 내용으로 가지고 수신만 가능함

커스텀

- 개발자 애플리케이션, 앱간또는앱내 통신을 목적으로 송수신모두가능

# Q.11) **ContentProvider의 목적은 무엇이며, 애플리케이션 간의 안전한 데이터 공유를 어떻게 용이하게 하나요?**

**ContentProvider**는 앱 간에 **구조화된 데이터를 안전하고 효율적으로 공유**하기 위한 중요한 컴포넌트입니다.

- **목적:** 내장된 데이터 저장 메커니즘을 추상화하고, 외부 컴포넌트가 데이터에 안전하게 접근하기 위한 **표준화된 인터페이스** (CRUD 연산)를 제공합니다.
- **안전한 데이터 공유:** ContentProvider는 데이터 접근을 위한 **세분화된 보안 제어를 허용**합니다. 데이터 무결성, 보안 및 안드로이드 시스템 기능과의 호환성을 보장합니다. 또한 ContentResolver는 다른 앱이 ContentProvider를 통해 데이터를 쿼리하거나 수정하는 데 사용

## 실전 질문

Q) ContentProvider URI의 주요 구성 요소는 무엇이며,
ContentResolver는 데이터를 쿼리하거나 수정하기 위해
ContentProvider와 어떻게 상호 작용하나요?

- 스키마, Authority,Path
- ContentResolver 객체에 URI와 필요한 데이터를 담아 `query()`, `insert()`, `update()`, `delete()` 와 같은 메서드를 호출하고 provider 검색 → 작업을 위임함 url랑 path, 쿼리 파라미터 등 다 전달, → 데이터 처리 작업을 수행하고 결과를 resolver에게 반환

표준화된 URI와 ContentResolver API만으로 안전하게 다른 앱의 데이터에 접근
